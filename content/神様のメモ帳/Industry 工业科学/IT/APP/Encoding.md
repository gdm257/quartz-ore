---
tags:
- Label/Article/APP
---

[字符集编码与乱码 – 肖国栋的i自留地](https://xiaogd.net/category/%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81%e4%b8%8e%e4%b9%b1%e7%a0%81/)

[JELLY | URL编码的奥秘](https://jelly.jd.com/article/6006b1045b6c6a01506c87e8)


### Charset & Charset Encoding

[字符集与编码（一）——charset vs encoding | 肖国栋的i自留地](https://xiaogd.net/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e4%b8%80%ef%bc%89-charset-vs-encoding/)

[字符集与编码（二）——编号 vs 编码 | 肖国栋的i自留地](https://xiaogd.net/md/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e4%ba%8c%ef%bc%89-%e7%bc%96%e5%8f%b7vs%e7%bc%96%e7%a0%81)

[字符集与编码（四）——Unicode | 肖国栋的i自留地](https://xiaogd.net/md/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e5%9b%9b%ef%bc%89-unicode)


| Character Set |    Character Set Encoding    |
| ------------- | ---------------------------- |
| ASCII         | ASCII                        |
| GB2312        | GB2312                       |
| GBK           | GBK                          |
| Unicode       | UTF-8, UTF-16, UTF-32, UCS-2 |
| LATIN1        |                              |
|               |                              |
|               |                              |


- Character Set (字符集) 缩写 Charset，有时也叫 Coded Charset.
- Character Set Encoding (字符集编码) 缩写 Charset Encoding 或 Encoding，简称编码.
- 把coded charset 译成”编号字符集”也许更不易引发误解。
- 早期的字符集只有一种字符集编码实现，因此它们无需区分字符集与编码.
- Unicode 字符集有多种编码实现，因此必须严格区分 Charset 与 Encoding.
- 并不存在名为 UTF-8 的字符集，UTF-8 是编码.
- ANSI 并不特指一种编码，ANSI 指的是系统的默认编码，不同系统默认编码不同.
- 一个字符集可以有多个编码实现，Unicode 字符集有 UTF-8 UTF-16 UTF-32 编码.
- 所谓实现，或者说编码，就是怎么把一个 Unicode 字符变成 bytes.
- 每个合法的 bytes 一定对应某种编码格式.
- Code Point (码点) 是一个 Character (字符) 的独一无二的 Code (编号).
- Code Point 书写格式为 U+HHHH U+HHHHH U+HHHHHH，即 4、5、6 位十六进制数.
- Code Point 十六进制数不足 4 位那就前补 0 补到 4 位.
- Code Point 范围为 U+0000 到 U+10FFFF，对应十进制为 0 到 1,114,111.
- 为了更好分类管理如此庞大的码点数，把每 65536 个码点作为一个平面 (Plane)，总共 17 个平面，即 Plane 0 - Plane 16。
- Plane 0 被称为 BMP (Basic Multilingual Plane 基本多语言平面).
- Plane 1-16 被称为 SP (Supplementary Plane 增补平面).
- BMP 的 U+D800-U+DFFF 没有任何字符，这就是 Surrogate Area (代理区).
    - U+D800-U+DBFF 属于 High Surrogate Area (高代理区)，容量为 1024.
    - U+DC00-U+DFFF 属于 Low Surrogate Area (低代理区)，容量为 1024.
- BMP 的 U+E000-U+F8FF 为 Private Use Area (私有区域)，容量为 6400.


> 广义上说，编号也可看成是某种编码。
> 狭义上说，编码也可视作为某种编号。
> 编号与编码的主要区别在于编号不涉及具体使用多少字节来表示、是用定长还是变长方案等细节问题。编号仅仅是一个抽象的概念，是把字符数字化的一个过程。

莫非「纯编号」就是 Unicode 字符集的早期「Encoding 实现」？
——这好像是 UCS-2


### 编码的分隔

自然语言中我们可以使用空格，标点来减少歧义的发生。在计算机里，一切都数字化了，包括所谓的空格，标点之类的分隔符。

在空格与标点都被数字化的情况下，我们在这一串 01 中如何去找出分隔来呢？显然我们需要外部的约定。

8位（bit）一组的字节是最基本的一个约定，也是文件的基本单位，文件就是字节的序列。字节显然就是最基础的一个分隔依据。

所以现在问题就成了 1 个字符应该用多少个字节表示。





### UTF-32

[字符集与编码（四）——Unicode | 肖国栋的i自留地](https://xiaogd.net/md/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e5%9b%9b%ef%bc%89-unicode)


关于以下三种编码方案的定变长与字节数总结：

    UTF-8：变长，1-4 字节；
    UTF-16：变长，2 或 4 字节；
    UTF-32：定长，4 字节。


我们说码点最大的 10FFFF 也就 21 bits，而 UTF-32 采用的**定长四字节**则是 32 位，所以它表示所有的码点不但毫无压力，反而绰绰有余，所以只要把码点的表示形式以前补 0 的形式补够 32 位即可。这种表示的最大缺点是占用空间太大。


### UTF-8

[字符集与编码（四）——Unicode | 肖国栋的i自留地](https://xiaogd.net/md/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e5%9b%9b%ef%bc%89-unicode)

UTF-8 是变长的编码方案，可以有 1，2，3，4 四种字节组合。在前面的定长与变长篇章我们提到 UTF-8 采用了高位保留方式来区别不同变长。

所谓高位保留，类似 A B C D 类 IP，A 类 IP 开头几位一定满足什么条件，不满足一定是其他三类之一。你可以理解为共有 4 种不同前缀，分别对应  1，2，3，4 字节。单字节最高位都是 0，多字节的最高位都是 1。110 为 2 字节，1110 为 3 字节，11110 为 4 字节。多字节方面，更具体的讲，N 字节模式，首字节以“N 个 1 再加 0 ”打头，后跟“N-1”个以“10”打头的字节。

1. 一字节有效编码位有 7 位，2^7=128，码点 U+0000 ~ U+007F（0~127）使用一字节。    一字节留给了 ASCII，所以 UTF-8 兼容 ASCII。

2. 二字节有效编码位只有 5+6=11 位，最多只有 2^11=2048 个编码空间，所以数量众多的汉字是无法容身于此的了。码点 U+0080 ~ U+07FF（128~2047）使用二字节。

3. 三字节模式可看到光是保留位就达到 4+2+2=8 位，相当一字节，所以只剩下两字节16位有效编码位，它的容量实际也只有65536。码点U+0800~U+FFFF（2048~65535）使用三字节编码。我们前面说到，一些汉字字典收录的汉字达到了惊人的 10 万级别。基本上，常用的汉字都落在了这三字节的空间里，这就是我们常说的汉字在 UTF-8 里用三字节表示。当然了，这么说并不严谨，如果这 10 万的汉字都被收录进来的话，那些偏门的汉字自然只能被挤到四字节空间上去了。

4. 四字节的可以看到它的有效位是 3+6+6+6=21 位，前面说到最大的码点 10FFFF 也是 21 位，U+FFFF 以上的增补平面的字符都在这里来表示。

按照 UTF-8 的模式，它还可以扩展到 5 字节，乃至 6 字节变长，但 Unicode 说了码点就到 10FFFF，不扩充了，所以 UTF-8 最多到四字节就足够了。




### UTF-16

UTF-16 是一种变长的 2 或 4 字节编码模式。对于 BMP 内的字符使用 2 字节编码，其它的则使用 4 字节组成所谓的代理对来编码。

什么是代理区？

在前面的鸟瞰图中，我们看到了一片空白的区域，这就是所谓的代理区（Surrogate Area）了，代理区是 UTF-16 为了编码增补平面中的字符而保留的，总共有 2048 个位置，均分为高代理区（D800–DBFF）和低代理区（DC00–DFFF）两部分，各1024，这两个区组成一个二维的表格，共有 1024 × 1024 = 16 × 65536，所以它恰好可以表示增补的 16 个平面中的所有字符。当然了，说恰好是不对的，显然代理区就是冲着表示增补平面来设计的，或者至少它们是一起考虑的。

什么是代理对？

一个高代理区（即上图中的Lead（头），行）的加一个低代理区（即上图中的Trail（尾），列）的编码组成一对即是一个代理对（Surrogate Pair），必须是这种先高后低的顺序，如果出现两个高，两个低，或者先低后高，都是非法的。


### ASCII

[字符集与编码（八）——ASCII 和 ISO-8859-1 | 肖国栋的i自留地](https://xiaogd.net/md/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e5%85%ab%ef%bc%89-ascii%e5%92%8ciso-8859-1)


### GB2312 & GBK & GB18030

[字符集与编码（九）——GB2312，GBK，GB18030 | 肖国栋的i自留地](https://xiaogd.net/md/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e4%b9%9d%ef%bc%89-gb2312%ef%bc%8cgbk%ef%bc%8cgb18030)


### 代码单元

什么是代码单元？UTF-8，UTF-16 和 UTF-32中的 8，16 和 32 究竟指什么？

代码单元指一种转换格式（UTF）中最小的一个分隔，称为一个代码单元（Code Unit），因此，一种转换格式只会包含整数个单元。
各种UTF编码方案下的代码单元

    UTF-8 的 8 指的就是最小为 8 位一个单元，也即一字节为一个单元，UTF-8 可以包含一个单元，二个单元，三个单元及四个单元，对应即是一，二，三及四字节。
    UTF-16 的 16 指的就是最小为 16 位一个单元，也即两字节为一个单元，UTF-16 可以包含一个单元和两个单元，对应即是两个字节和四个字节。我们操作 UTF-16 时就是以它的一个单元为基本单位的。
    同理，UTF-32 以 32 位一个单元，它只包含这一种单元就够了，它的一单元自然也就是四字节了。

所以，现在我们清楚了：

    UTF-X 中的数字 X 就是各自代码单元的位数。



### BOM

一句话：不带 BOM。

UTF-8 不需要 BOM，所有人一致对 UTF-8 采用大端法，也就不需要额外信息（BOM）来注明文件是用哪种端法存储的。windows 记事本默认给文本加上了 BOM，显然是多此一举，结果遭受大量谩骂也是可想而知的了。

对 UTF-16 来说，BOM 是必须的，因为它是存在字节序的，弄反了字节序一个编码就会变成另一个编码了，那就彻底乱套了。不过一般很少用 UTF-16 编码来保存文件的，更多是在内存中使用它作为一种统一的编码。

其实关于端法及 BOM 并没有太多好说的，通常大家知道有这么一回事或者说有那么一些“坑”也就够了，关于 BOM 的话题就谈到这里。



### 坑蒙拐骗


    约定俗成是唯一的解决办法。


文本文件作为一种通用的文件，在存储时一般都不会带上其所使用编码的信息。编码信息与文件内容的分离，其实这正是乱码的根源。

如果内容中没有编码信息，又要去确定它使用的编码，这不是为难人是什么？好在“坑蒙拐骗”中的第二招“蒙”可以拿来用用。

“蒙”其实也是要讲点技术含量的，简单点自然就是模式匹配了，或许一个或几个正则式就完了；复杂点，什么概率论，统计学，大数据统统给它弄上去，那逼格立马就高了有木有？当然了，记事本也就是一跑龙套的…

如果既没有 BOM，又无法猜测出所使用的编码，那是否就只能是两眼一抹黑了呢？

前面说到，文本文件中没有编码信息，导致了各种混乱，那么，最关键的就是要指定好所用的编码信息。具体地讲，有以下一些途径。

1. 变相引入

什么是变相引入呢？其实本质与前面提到的一些“文件头”信息是类似的。

我们来看看 xml 文件的例子，你通常能在最开始看到这样的一行：

<?xml version="1.0" encoding="UTF-8"?>

那么这里面，encoding 指明的就是所用编码的信息了。

可是，等等！！为了得到这一编码信息，我得先读取这一文件；可要正确读取文件，我又要先知道编码信息！

怎么破呢？考虑这一行信息所有字符都是 ASCII 中的字符，那么我们可以先使用最基础的 ASCII 去读取它开头的一些信息，获取到这一编码信息后，再次用这一编码去读取文件即可。



2. 外部指定

既然没有编码信息，又不打算用变相的方式指定，那么靠谱的方式就是外部显式指定了。

例如解压时指定 GBK 编码 unar -e GBK abc.zip
