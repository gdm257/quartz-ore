---
tags:
- Label/Article/APP
---

[Linux 云平台 Linux 服务器问题场景分析思路及工具箱 command not found 未找到命令 云平台 Linux 服务器问题场景分析思路及工具箱详解 云平台 Linux 服务器问题场景分析思路及工具箱未找到 云平台 Linux 服务器问题场景分析思路及工具箱安装 - CommandNotFound ⚡️ 坑否](https://commandnotfound.cn/linux/1/186/%E4%BA%91%E5%B9%B3%E5%8F%B0-Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%AE%B1)

[一道面试题：说说进程和线程的区别 - FooFish](https://foofish.net/thread-and-process.html)

pmap
pstack
strace
ipcs
iostat

————————————————————————————————
|                              |
|        前台进程、后台进程、Daemon、Service
|                              |
————————————————————————————————

[前后台进程、孤儿进程和daemon类进程的父子关系 | 骏马金龙](https://www.junmajinlong.com/linux/process_relationship/)

「前台进程」：子进程会阻塞终端，即子进程运行期间会导致终端进程一直被挂起，那么该子进程就是个前台进程。例如在 bash 终端执行 `sleep 10`.

「后台进程」：子进程不阻塞终端，各干各的，但子进程的 PPID 仍然是终端，也就是说子进程不是孤儿进程，那么该子进程就是个后台进程。例如在 bash 终端执行 `sleep 10 &`.

「Daemon」：父进程 fork 子进程，然后父进程直接退出（或者被杀死），子进程成为孤儿进程，孤儿进程的父进程会变成 PID 1。也就是说，子进程脱离了 shell 环境（父进程），直接由 PID 1 管理，这样的进程称为 Daemon（守护进程）。可见守护进程没什么特殊的，就是一直运行的孤儿进程。任何守护进程都有过一个瞬间就退出的父进程。例如 rclone mount，不加 `--daemon` 会阻塞父进程（占用终端），加了 `--daemon` 则变为守护进程。利用 `htop` 或 `pstree` 看一下就懂了。

「Service」：受 systemd/SysV 管理的进程，或者说是 systemd/SysV 根据配置启动的进程，仅此而已。Service 能被 `systemctl` `service` 之类的命令管理。例如，`systemctl start ssh` 启动的进程就是个 service 进程，而手动执行 `sshd` 命令所启动的进程就不是 service 进程。

对 Kernel 而言，其实根本就不会区分「前台进程」「后台进程」「Daemon」「Service」——它们都只是「进程」，可以轻易的用 `kill` 杀死。Kernel 只区分这是个内核进程，还是个用户进程。

杀死一个进程后，该进程的后代进程会被杀吗？
不会。祖先进程与后代进程并没有强依赖关系，所谓父子关系，只不过是在进程表里添加了一个「PPID」属性。
孤儿进程会继续保持运行，而不会随父进程退出而终止，只不过孤儿进程的父进程会变成 PID 1，这就是产生 Daemon 的原理。




————————————————————————————————
|                              |
|          task_struct
|                              |
————————————————————————————————


[16.1 什么是程序 （process） | 鸟哥的 Linux 私房菜：基础学习篇 第四版](https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/139.html)


每个进程都会有进程组ID (PGID)，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的 PGID。因此，我们可以通过 `pkill` 杀死进程组来达到「结束一个进程及其后代进程」的效果。



task_struct 是进程最主要的标志。
从本质上讲，创建进程最主要的就是创建task_struct。

进程0不能由父子进程创建机制创建，所以只能由操作系
统设计者手工编写进程0的task_struct。有了进程0，父
子进程创建机制就可以用进程0作为父进程创建子进程。

每个进程都有一个工作目录（working directory）
所有相对路径名都从工作目录开始解释。
进程可以用chdir函数更改其工作目录。

每个进程都有一个唯一的数字标识符，称为进程ID（process
ID）。进程 ID总是一个非负整数。

程序（program）是一个存储在磁盘上某个目录中的可执行文件。
程序的执行实例被称为进程（process）。

有3个用于进程控制的主要函数：fork、exec和waitpid。（exec函数有7种
变体，但经常把它们统称为exec函数。）

在类UNIX
操作系统的设计者看来，操作系统的核心就是进程。所
谓的操作系统就是若干个正在运行、操作的进程构成的
系统。按照这个思路，进程的创建只可能由进程承担，
也就是父子进程创建机制。在任何情况下，至少得有一
个进程留守，这就是进程0。与计算机使用者交互也是由
专门的进程（即shell）负责。总之，一切皆为进程。



一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关
的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采
取同步措施以避免不一致性。

