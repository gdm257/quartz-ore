---
aliases:
- 《On Java 8》
tags:
- Label/Book
- flag/LANGUAGE/Java
---

## Ch. 01

组合、聚合没看懂.
组合很好理解，但聚合是什么，为什么说代码层面无法区分二者？
mixin 是典型的组合，但组合、继承到底是什么？区别？

封装
> 基类包含派生自它的类型之间共享的所有特征和行为。创建基类以表示思想的核心。从基类中派生出其他类型来表示实现该核心的不同方式。
> 类型层次结构体现了形状之间的相似性和差异性。

is-a & is-like-a --- 派生类是否添加新方法

后期绑定、动态绑定
运行的时候才能知道要执行哪个函数。
这种把子类当成其基类来处理的过程叫做“向上转型”（upcasting）。在面向对象的编程里，经常利用这种方法来给程序解耦。
发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。编译器和运行时系统会负责对所有细节的控制；我们只需知道要做什么，以及如何利用多态性来更好地设计程序。


泛型
向上转型 upcasting 会丢失子类的特性，但我们为了解耦又不得不只使用基类，有没有什么办法同时满足二者呢？有，这就是泛型，泛型实现了动态的「向下转型」。
Java 5 支持了 参数化类型机制（Parameterized Type Mechanism），称之为「泛型」。


“集合”（Collection）也可称之为“容器”，但“集合”这个称呼更通用。
“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。
List，常用于保存序列；
Map，也称为关联数组，常用于将对象与其他对象关联；
Set，只能保存非重复的值；
队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等



## Ch. 02

引用
`String s;` 只是创建了一个 String 对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量 s 赋值--指向任何对象。
`String s = "abc";` 通常更安全的做法是：创建一个引用的同时进行初始化。
我们所操纵的标识符实际上只是对对象的“引用”
`String s = new String("abc");` 在 Java 中，通常我们使用new操作符来创建一个新对象。new 关键字代表：创建一个新的对象实例。

疑惑：类成员标识符与实例成员标识符是同一标识符吗？例如，我重新赋值了类字段，实例会受影响吗？
不清楚，至少 `static` 成员执行 `++` 是会影响实例的。
我们可以通过对象引用静态方法，但使用类名直接引用静态变量是首选方法，因为它强调了变量的静态属性。类似的逻辑也适用于静态方法。


疑惑：Java 区不区分可变对象、不可变对象？`i++` 会不会创建新对象？




如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。
这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。
接口呢？
枚举呢？


方法名和参数列表统称为方法签名（signature of the method）。签名作为方法的唯一标识。
修饰符与 C# 作用一致，类成员用法也一致。




## Ch. 04

Javaの直接赋值 与 Python 是一样的，都是标识符指向对象。
重新赋值 == 标识符指向新对象
方法的入参能很好的证明这点，即入参只是传递了一个引用
关键词「pass by reference 引用传递」「pass by value 值传递」
到现在为止，你已经对“传递”对象实际上是传递引用这一想法想法感到满意。

`++i` 前递增
      先执行递增/减运算，再返回值。
`i++` 后递增
      先返回值，再执行递增/减运算。
`++` 是运算符，是个表达式，而非语句
如果 `++` 表达式被用在赋值语句（包括作为方法入参），那么前后递增才有区别。
`++i` 先递增，再执行赋值；
`i++` 先执行赋值，再递增；


## Ch. 05

goto break continue——"标签"机制
goto 从未被 java 正式启用，当作不存在吧，可以说，java "不支持" goto

疑惑：switch 的 break 是结束 switch 还是仅结束 case 不结束 default？
switch-default 是 if-elseif-else 语法糖，这样理解。



## Ch. 06

Java 通过方法签名（方法名 + 参数列表）来区分同名的重载方法。
如果两个方法命名相同，Java是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你甚至可以根据参数列表中的参数顺序来区分不同的方法，尽管这会造成代码难以维护。

Constructor
如果你创建一个类，类中没有构造器，那么编译器才会自动为你创建一个无参构造器。

self & this
a = A()
a.func01(257) == A.func01(a, 257)
可以看出，Java 和 Python 都将实例对象本身作为 method 的第一个参数，只不过 python 在形参中显式定义了 self，而 java 是隐式定义。调用成员方法时 Java 和 Python 都会隐式将实例对象作为第一个参数传入。
类成员通过变量 `this` 指代实例对象，相当于 Python 的 `self`.
如果你在一个类的方法里调用该类的其他方法，不要使用 this，直接调用即可.
当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过 this 关键字实现这样的调用。


GC & finalize()
看不懂.


成员初始化
在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为 null。

顺序：    书中的案例与解释有矛盾，乱的一批
JVM
import
定义类
    声明类成员 (相当于函数提升)
    初始化 static field
    初始化 field
    Constructor
main()
    实例化
        初始化 field
        Constructor



数组初始化
写的真乱，建议找文章代替
`int[] a;`
`a = new int[10];`    注意此处的特殊语法，Python 没有的
`int[] a = new int[10];`
`int[10] a;`    错误写法，a 是对象引用，不能指定数组长度，`int[10]` 必须配合 new 才能使用

`new Object[] {3.14, 257, "abc"}`



## Ch. 08

都写的啥啊，看不懂.

Composition 组合


Inheritance 继承

每个非基本类型对象都有一个 `toString()` 方法



