---
tags:
  - Label/Article/Industry-工业科学/IT/Mindset/Architecture
---

[你的项目应该如何正确分层？ - 掘金](https://juejin.cn/post/6844903636334542856)

[MVC，MVP 和 MVVM 的图示 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)

[对DRF框架后端API开发的一些个人心得 | 逐暗的小站](https://www.zhu-an.cn/todo/%E5%AF%B9DRF%E6%A1%86%E6%9E%B6%E5%90%8E%E7%AB%AFAPI%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/)

[Django工程的分层结构 - 昀溪 - 博客园](https://www.cnblogs.com/rexcheny/p/11207630.html)


我觉得比较由雅的分层

Web层/GUI层/CLI层
Service层
Entity层




MVC在bs架构和cs架构上差别很大，即使同是bs，因为使用的技术的差别，业务的差别，架构的差别，MVC的通信方式也会和原来你书本上看到的不一样。就像backbonejs和angularjs的出现，是发明还是延伸，还是糟蹋？每天和它一起工作的人才知道。
所有的设计应该以贴近自然或接近自然规律为目标。再通俗的讲，用的舒服就是自然。好的东西绝对不需要强记一堆原理来理解的。

B/S、C/S、GUI、CLI 对 MVC 的理解与实践都截然不同。

看看阮一峰老师的文章就知道，他文中所说的 MVC、MVP 和 MVVM 的绝对和后端的理解大不相同，评论已经有很多讨论了。

我或许应该从具体框架入手，Django、Flask、FastAPI、Qt、Electron 项目的具体结构是什么样的，之后再试图理解 MVXX。






[[ChatGPT]]
在Java后端项目中，一般会按照三层或四层架构来划分不同的功能模块和责任。

1. 表现层/用户界面层（Presentation Layer）：负责处理用户请求和响应，通常使用MVC（Model-View-Controller）模式来实现。它包括处理请求、校验参数、渲染模板、返回响应等工作。

2. 业务逻辑层/服务层（Business Layer/Service Layer）：负责处理业务逻辑，对外提供各种服务接口。它包括处理业务规则、数据校验、事务管理、协调不同的数据访问对象等工作。

3. 数据访问层/持久化层（Data Access Layer/Persistence Layer）：负责与数据库或其他数据存储系统进行交互，包括数据的增删改查等操作。它通常使用DAO（Data Access Object）模式来封装数据访问操作。

4. 可选的领域模型/领域层（Domain Model/Domain Layer）：在一些复杂的项目中，可能会引入领域模型层来表示业务领域中的概念和规则。它包括业务实体、值对象、服务等。

这些层之间通过接口和调用来进行通信，便于各层之间的解耦和单独的开发和维护。同时，这种分层的架构也能使代码更加模块化、可扩展和可测试。需要根据具体的项目需求和规模来确定是否需要引入所有层，并可以根据实际情况进行调整和改进。





简单来说，业务逻辑层调用 Dao 的 API；Dao 调用 (ORM) Model 的 API。

还是那句话，中间层思想

有了 ORM 为什么还要 DAO？一句话，DAO 可以做到，无论之后别人想换任何奇奇怪怪的 orm 都没问题。

ORM 始终还算作 db 那一层，与 MySQL Library、Redis Library 属于同一层级，避免手撸 SQL query。Service（业务逻辑）不应该直接调用 db 层，所以就有了 DAO 层

[[ChatGPT]]
DAO 和 ORM 并不冲突，它们是两个不同的概念和技术。

DAO（Data Access Object）是一种用于将数据访问逻辑（如读写数据库或其他数据存储系统）与业务逻辑（如业务规则）分离的设计模式。在 DAO 模式中，数据访问逻辑被封装在数据访问对象中，使得服务层或其他中间层可以专注于业务逻辑，从而提高代码的可维护性和可测试性。

ORM（Object-Relational Mapping）是一种技术，用于将对象模型与关系数据库模型中的数据进行映射，即将 Java 对象自动映射到关系数据库中的表，以及将表中的数据自动映射回 Java 对象中。ORM 通过隐藏对数据库的直接访问，使开发人员从手动编写 SQL 语句和数据访问代码中解放出来。

因此，DAO 和 ORM 都是用于降低代码耦合度和提高代码可维护性的技术，它们并不冲突。在实际应用中，我们可以结合使用 DAO 和 ORM 来提高代码的可重用性和可测试性。例如，使用 DAO 模式来将数据访问逻辑与业务逻辑分离，并使用 ORM 框架来实现数据的持久化操作。这种方式可以让我们更加关注业务逻辑的实现，同时也让数据访问操作更加简便。





[[ChatGPT]]
在一个典型的 Java 后端项目中，业务逻辑层（Service 层）通常会依赖于 DAO 层和 ORM 层来完成数据操作和持久化。下面是它们之间的调用关系：

1. 业务逻辑层调用 DAO 层：业务逻辑层会调用 DAO 层的接口方法来获取或保存数据。通过 DAO 层暴露的方法，业务逻辑层可以调用各种数据查询、插入、更新和删除的操作。

2. DAO 层调用 ORM 层：DAO 层会使用 ORM 框架提供的 API 来进行数据的持久化操作。ORM 层通过将 Java 对象与数据库表进行映射，提供了一系列的 API 来执行数据查询、插入、更新和删除等操作。DAO 层会使用这些 API 来实现具体的数据操作。

3. 业务逻辑层不直接调用 ORM 层：业务逻辑层一般不直接调用 ORM 层的 API。业务逻辑层将数据访问的具体实现交给 DAO 层来处理，而不需要关注具体使用的是哪个 ORM 框架。这样做可以降低耦合性，使业务逻辑层更加独立和可测试。

通过以上调用关系，业务逻辑层能够聚焦于业务规则的实现，而 DAO 层负责数据的访问和持久化，ORM 层负责对象与数据库之间的映射。这种分层架构可以提高代码的可维护性、可扩展性和可测试性，并且使不同层之间的责任分工更加清晰。




有人说，Repository 与 DAO 的不同主要在于。DAO 这个贫血 Entity 需要手动实现，Dao 类越多，就越多复制粘贴，最后会造成不方面统一修改代码。Repository 则可以平替 Dao，但同时支持依赖注入、AOP，更加黑魔法，更加 OOP
