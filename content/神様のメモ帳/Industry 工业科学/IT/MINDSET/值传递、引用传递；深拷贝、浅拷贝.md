---
tags:
- Label/Article/Industry-工业科学/IT/LANGUAGE
---

[什么是所有权？ - Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html)


    值传递
    引用传递
    浅拷贝 shallow copy
    深拷贝 deep copy
    对象
    属性
    标识符
    指针
    引用
    值类型
    引用类型
    可变对象
    不可变对象


- 函数入参为左值 の 按值传递（深拷贝、浅拷贝）、按引用传递
- 变量为左值 の 按值传递（深拷贝、浅拷贝）、按引用传递
- 对象属性为左值 の 按值传递（深拷贝、浅拷贝）、按引用传递
- **导入模块为左值 の 按值传递（深拷贝、浅拷贝）、按引用传递**
- 所谓左值，就是标识符.
- 命名空间是一种包含多个键值对の数据结构.
- 标识符就是命名空间的键名.

按值传递：假设 B = A 是按值传递，那么 B 是 A 的拷贝（浅拷贝、深拷贝或其他拷贝方式）。典型的如 Python 的不可变对象。

按引用传递：假设 B = A 是按引用传递，那么 B 与 A 指向同一内存对象。典型的如 Python 可变对象。

浅拷贝：假设 B 是 A 的浅拷贝。对象 B 的属性与对象 A 的属性同名、且指向同一对象。

深拷贝：假设 B 是 A 的浅拷贝。对象 B 的属性与对象 A 的属性同名、但指向不同对象，并且「该属性所指向的对象」的属性也是指向与 A 无关的对象，以此类推，无限递归。A 和 B 在内存中没有任何关联与交集。

不可变对象（immutable）：不严谨的说，就是其值（属性）不能改变的对象。如果必须存储一个不同的值，则必须创建新的对象。

可变对象（mutable）：不严谨的说，就是其值（属性）可以改变的对象。可变对象可以在其 id() 保持固定的情况下改变其取值。


「可变/不可变」与「按值传递/按引用传递」没有必然关系，完全可以进行各种排列组合，语言作者可以根据自己的意图采取任何一种方案。

Python 的方案是，对「可变对象」采取「按引用传递」，「不可变对象」采取「按值传递」。

Rust 则不同，无论「可变对象/不可变对象」，都是「按值传递」。想要实现「按引用传递」的效果，则需要显式使用「Reference 对象」。

C# 无论什么对象，都是「按值传递」。想要达到「按引用传递」的效果，需要显式使用指针。

「不可变对象」并不意味着「按值传递」，「可变对象」也不一定是「按引用传递」，上面的几个例子已经体现的很明显了。



标识符作为左值 与 属性作为左值，不应该有任何差别。因为标识符本质是命名空间的属性