---
tags:
- Label/Article/Industry-工业科学/IT/LANGUAGE
---

[如何降低软件的复杂性？ - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2018/09/complexity.html)

[系统困境与软件复杂度：为什么我们的系统会如此复杂？ - 掘金](https://juejin.cn/post/7067725791001313317)


如何编排程序结构？记录以下自己的理解：

0. 一个 CLI App 应该满足「参数解析」「真・回调函数」零耦合。标准就是，在不改一行「真・回调函数」的代码的前提下，「回调函数」应该能直接用于 GUI 开发，甚至是作为一个包使用.
1. 一个 CLI App 应该满足「GUI」「真・回调函数」零耦合。标准就是，在不改一行「真・回调函数」的代码的前提下，「真・回调函数」应该能直接用于 CLI 开发、其他 GUI 方案，甚至是作为一个包使用.
2. 遵守「依赖倒置原则」极其重要，让我们可以将一个库替换为完全不同的另一个库，但程序的行为不会有任何改变.
3. 读取完配置再真正进入程序
        全局配置文件
        用户配置文件
        便携配置文件
        环境变量
        命令行参数
        覆盖默认配置
4. 带有 main 函数的文件必须能直接编译为可执行文件，否则应该换个名字.
5. 一定要手动 close 的对象，应该在创建它的作用域进行关闭操作。除非某些框架支持 hooks，那么可以在 hook 函数中关闭。因此这种对象不能作为全局变量.
6. 模块内部的文件用 `__file__`，模块外部的文件用 `sys.argv[0]` 或 `cwd`.
7. 即便是 Python，也不提倡直接修改实例的「class 里就定义了的实例属性」，一般都是对外提供一个相关的方法（不仅限于 setter，单独修改属性意义不大）.
8. 在 `__init__()` vs getter/setter，本质是风格问题，无关好坏。对外开放的实例字段，我选 getter，原因很简单，getter 的可读性强一些，我不想 `__init__()` 里边充满面条代码。内部实例字段，出于习惯，都在 `__init__()` 里定义，如果你确定内部实例字段一定是不可变对象，那么可以用 类字段 代替。毕竟类属性、实例属性本质是一样的，都是对象的属性，只不过初始化时机不同.