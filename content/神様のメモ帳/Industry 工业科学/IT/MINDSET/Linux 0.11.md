---
tags:
    - Label/Article/Industry-工业科学/IT/APP/OS/BootLoader
---

# Linux 0.11

## Bios

CPU的逻辑电路被设计为只能运行内存中的程序。
在RAM中什么程序也没有的时候，谁来完成加载软盘中操作系统的任务呢？
答案是：BIOS。
但是，在开机加电的一瞬间，内存中什么程序也没有，那么BIOS程序又是由谁来执行的呢？
既然用软件方法不可能执行BIOS，就只能靠硬件方法完成了。
秘诀是：0xFFFF0
Intel将所有80x86系列的CPU，包括最新型号的CPU的硬件都设计为加电即进入16位实模式状态运行。
同时，将CPU硬件逻辑设计为加电瞬间强行将CS的值置为0xF000、IP的值置为0xFFF0，这样CS：IP就指向0xFFFF0这个地址位置
BIOS程序的入口地址恰恰就是0xFFFF0！
这是一个纯硬件完成的动作！如果此时这个位置没有可执行代码，那么就什么也不用说了，计算机就此死机。反之，如果这个位置有可执行代码，计算机将从这里的代码开始，沿着后续程序一直执行下去。
CS（Code Segment Register）：代码段寄存器，存在于CPU中，指向CPU当前执行代码在内存中的区域（定义了存放代码的存储器的起始地址）。


BIOS程序被固化在计算机主机板上的一块很小的ROM芯片里。
BIOS程序的代码量并不大，却非常精深，需要对整个计算机硬件体系结构非常熟悉才能看得明白。要想把BIOS是如何运行的讲清楚，也得写很厚的一本书


INT（INTerrupt）
对于Linux 0.11操作系统而言，计算机将分三批逐次加载操作系统的内核代
码。
第一批由BIOS中断int 0x19把第一扇区bootsect的内容加载到内存；
    这段BIOS程序所要做的就是“找到软盘”并“加载第一扇区”
    这个扇区里的内容就是Linux 0.11的引导程序,bootsect
第二批、第三批在bootsect的指挥下，分别把其后的4个扇区和随后的240个扇区的内容加载至内存。
    boot sector 启动扇区 的作用就是陆续把软盘中的操作系统程序载入内存
    从此计算机开始和软盘上的操作系统程序产生关联。


操作系统和BIOS通常是由不同的专业团队设计和开发的，为了能协同工作，必须建立操作系统和BIOS之间的协调机制。
难点在于与未来的操作系统应该如何建立协调机制。现行的方法是“两头约定”和“定位识别”。
对操作系统（这里指Linux 0.11）而言，“约定”操作系统的设计者必须把最开始执行的程序“定位”在 boot sector 启动扇区（软盘中的0盘面0磁道1扇区），其余的程序可以依照操作系统的设计顺序加载在后续的扇区中。
对BIOS而言，“约定”接到启动操作系统的命令，“定位识别”只从启动扇区把代码加载到0x07C00（BOOTSEG）这个位置（参见Seabios 0.6.0/Boot.c文件中的boot_disk函数）。至于这个扇区中是否是启动程序、是什么操作系统，则不闻不问、一视同仁。如果不是启动代码，只会提示错误，其余是用户的责任，与BIOS无关。

根文件系统设备（Root Device）


## bootsect

## setup

## head

## main

在执行main函数之前，先要执行三个由汇编代码生成的程序，即bootsect、setup和head。之后，才执行由main函数开始的用C语言编写的操作系统内核程序。

Linux0.11的代码是用C语言编写的。奇怪的是，为什么在操作系统启动时先执行的是三个由汇编语言写成的程序，然后才开始执行main函数；为什么不是像我们熟知的C语言程序那样，从main函数开始执行呢。

通常，我们用C语言编写的程序都是用户应用程序。
这类程序的执行有一个重要的特征，就是必须在操作系
统的平台上执行，也就是说，要由操作系统为应用程序
创建进程，并把应用程序的可执行代码从硬盘加载到内
存。现在我们讨论的是操作系统，不是普通的应用程
序，这样就出现了一个问题：应用程序是由操作系统加
载的，操作系统该由谁加载呢？

Linux 0.11是一个32位的实时多任务的现代操作系统，main函数肯定要执行的是32位的代码。
开机时的16位实模式与main函数执行需要的32位保护模式之间有很大的差距，这个差距谁来填补？head.s做的就是这项工作。

从借助BIOS将bootsect.s文件加载到内存开始，相
继加载了setup.s文件和system文件，从而完成操作系统
程序的加载。
接下来设置IDT、GDT、页目录表、页表以及机器系
统数据，为32位保护、分页模式下的main函数的执行做
准备。
一切就绪后，跳转到main函数执行入口，开始执行
main函数。



## interrupt




## PID 0

进程0现在处在3特权级状态，即进程状态。正式开
始运行要做的第一件事就是作为父进程调用fork函数创
建第一个子进程——进程1，这是父子进程创建机制的第一
次实际运用。

## PID 1


## PID 2


## shell

我们先来思考一个问题：所有的操作系统都要有用
户使用界面，就是所谓的shell。

一旦shell结束退出了，
操作系统就再也没有shell了。没有shell的操作系统就
是一个不可使用的操作系统，有什么存在价值呢？
由此可见，shell必须是一个专门为操作系统配套设
计的特殊进程，从开始接受用户使用到关机，都不应该
退出。

shell的本质是用户界面程序，掌控的是显示屏、键
盘等，这些都是外设。Linux操作系统的进程创建机制是
由父进程创建子进程。由此可推断，shell的父进程必须
有使用外设的能力以及可用的外设环境，可以推出父进
程就应该是进程1那样的进程。外设肯定是由主机掌控
的，所以，所有进程都必须有在主机中运行的能力，可
以推出进程1的父进程就应该是进程0那样的进程。

现在，我们可以看得更清楚，PID 0、PID 1、shell进程，
就分别对应 主机、 外设、 特殊的外设(用户界面)
