---
tags:
  - Label/Article/Industry-工业科学/IT/LANGUAGE
---

如何避免使用全局变量？

写脚本时发现不懂怎么 只初始化一次 同时还要 代码解耦（函数或类不依靠全局变量就能运行）。以下是我的思考与疑惑。

例如，需要在多个函数、多个类中使用外部的配置文件（并非作为参数，而是代码运行过程中需要各种调用，例如我写的 yidm，各个函数都要使用 header ua token etc 全局变量）。

如果不用全局变量，每次都需要 open、读取、解析，显然是错误的做法。

如果用了全局变量，那么就很容易全局变量满天飞（我写的 yidm 就是这样）。

如果把各种全局变量塞到一个全局 dict 里面，虽然可行，跟全局变量满天飞没有本质区别。

如果像 logging 那样使用类（数据类型），确实只需要实例化一个对象（数据），调用时就调用那个实例化对象（及其内置方法、属性）。但这本质上和「全局变量塞进一个 dict」里没有区别，只不过是把 dict 换成自定义 class 的 object 罢了。

以上任何一种方法，都不符合「模块化」的精神，一旦脱离了全局变量，代码就无法运行，即便你传入了正确的参数。

如果你将一大坨全局变量作为参数传入函数，确实能做到模块化，单纯只依靠入参而脱离全局变量运行。但这种做法未免太丑陋，我还没见过哪个函数的入参是一大坨重物的。

最后还有一种方法，将所有函数塞进一个 class，用类的成员变量来代替全局变量。但包括 python 标准库在内的各种开源库，没有一个是把所有东西都塞进一个 class 里的，但偏偏它们又能做到模块化、不使用全局变量，这让我感到非常神奇。

**综上，全局变量（共享但无法解耦）vs 模块化（无法共享、多次重新初始化），陷入了此消彼长的二元对立。**

据我观察，目前朝着「模块化」的方向发展，宁愿多次初始化、写重复代码、阻塞、同步，也要避免代码耦合。造成的资源浪费、同步、异步，都统统丢给各个语言的解释器去优化。

在我看来，只剩 2 种选择（2 个极端）：

1. **低耦合、高内聚**，宁愿多次初始化、重复运行同一段代码，就是不共享数据，例如 LANraragi，每个函数内部都会初始化一次 redis 对象；
2. **全局变量（对象）**，调用前至少初始化 1 次（例如 logging 的读取配置、创建 logger 对象）；

我个人更喜欢第一种，尽量解耦，全局变量能不用就不用。跟我对于深度学习的理解是一样的。

闭包？

问了下知乎，上面几点全被我说中了：

> 全局变量不能规避，只是有些可以不用全局变量表示的变量可以变成参数，但是又要避免过长的参数，对于相关的变量可以封装成对象，但是所有的全局变量依然是全局变量，没有被规避，因为你的需求就要求它是全局变量。

> 全局变量只是一类问题的一个现象。这类问题叫做shared mutable state。任何地方的变量只要在多个上下文间共享，就是潜在的问题，跟这个变量全不全局没有必然联系。


> 全局变量不用规避，只需要有序地归纳和整理
> 你依赖的 I/O 算不算全局变量，你依赖的 database 算不算全局变量? 任何有点价值的程序，都依赖大量的全局变量。针对确定的一段业务逻辑，全局变量只会转移，而不可能消失。
> 我们需要做的是如果能够不用全局变量实现的功能，例如可以用函数传参实现的传递，就不要依赖全局变量去传递。
> 然后是避免全局变量引起的“action at a distance”。就是你改了一个文件，产生影响的不是这个文件的其他函数，甚至不是这个目录下的其他函数。而是另外一个git仓库里，每个角落的函数受到了影响。那如何避免“action at a distance”呢? 就是要归纳和整理，把一个全局变量会互相受牵连影响的代码都收到同一个目录下，甚至是同一个文件里。这样出问题就好找了。

> 写代码,本身就是在开发效率与运行效率之间找平衡,为了可读性与可扩展性,牺牲一部分(甚至是很大一部分)运行效率,在绝对多数情况下,都是可接受的。
