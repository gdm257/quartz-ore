---
aliases:
- 并行
tags:
- Label/Article/Industry-工业科学/IT/LANGUAGE
---

[回调函数 - 术语表 | MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Callback_function)

[异步&回调&Promise - 知乎](https://zhuanlan.zhihu.com/p/100897077)

[同步、异步与回调 | 幸运的兔脚](https://rabbitfeet.net/archives/synchronous-aasynchronous-and-callbacks)

[完全理解回调函数 | Maples7's Blog](https://maples7.com/2017/10/17/understand-callback/)

[编程语言是如何实现并发的之并发模型篇 · 构建我的被动收入](https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/)

[golang中锁Mutex与通道channel的选择 - 序语程言](https://www.yangyanxing.com/article/query-mysql-in-go-base.html)

[100%弄明白5种IO模型 - 知乎](https://zhuanlan.zhihu.com/p/115912936)

[python异步IO完全指南 - Peter Griffin's杂货店](https://flyingbyte.cc/post/async_io/)

[python异步爬虫（异步、协程、线程池、生成器）- 良有以也](https://whuhan2013.github.io/blog/2016/09/13/python-ansyc-crawler/)

[Python 异步编程入门 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2019/11/python-asyncio.html)

[Python进阶——为什么GIL让多线程变得如此鸡肋？ - 掘金](https://juejin.cn/post/6906873301293858823/)

[去 async/await 之路 - 知乎](https://zhuanlan.zhihu.com/p/45996168)

《操作系统之哲学原理》

[操作系统修炼秘籍（2）：并行的假象和分时系统 | 骏马金龙](https://www.junmajinlong.com/os/time_sharing/)


    一切都是为了「并发/并行」这个终极目的
    「并发/并行」的手段是「异步」
    「并发/并行」操作同一个对象需要「锁」

    串行
    并行
    并发

    同步
    异步
    阻塞
    非阻塞
    多进程
    多线程
    多协程
    回调函数
    yield
    Promise
    async/await
    channel


一切的终极目的都是为了将程序中「串行」的任务变为「并发/并行」.
「并发/并行」的唯一实现方式就是「异步」.
「多协程」，或者说通过创建一个新协程可以实现「异步」.
「多线程」，或者说通过创建一个新线程可以实现「异步」.
「多进程」，或者说通过创建一个新进程可以实现「异步」.
「回调函数」可以实现「异步」.
「yield」可以实现「异步」.
「Promise」可以实现「异步」.
「async/await」可以实现「异步」.
「异步」指「异步调用」.
「同步」指「同步调用」.
「异步调用」
> 如果 JS 不能直接拿到一个函数的结果，可以先去执行别的代码，等结果到了再取结果，这就是异步
> 异步的结果可以通过回调获取，一般来说结果会被作为回调的第一个参数
> 异步与回调并没有直接的联系，回调只是异步的一种实现方式。
> 异步的好处是可以把用来等待的时间拿去做别的事情
「异步调用」不一定要使用「协程」。「协程」一定是「异步」，但「异步」不一定是「协程」。「协程函数」一定是「异步函数」，但「异步函数」并不一定是「协程函数」。例如「Python 的多进程」「Python 的多线程」都是异步调用，却没有使用「协程函数」。很多库说自己「支持异步」，这本应该是一种错误的说法，正确的说法是这些库「支持协程」，更准确的说是「提供协程函数和可等待对象」，但大家都这么说，也就将错就错了，我愿称之为「狭义的异步」，这种不准确的说法应该尽量避免。而真正的「异步」，即「广义的异步」，是包括「多进程」「多线程」「多协程」在内的.
「同步调用」是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用。
「调用」是「函数调用」的简称.
「异步函数」是指，如果一个异步函数被调用时，该函数会立即返回尽管该函数规定的操作任务还没有完成.
「同步函数」是指，当一个函数是同步执行时，那么当该函数被调用时不会立即返回，直到该函数所要做的事情全都做完了才返回.
「异步函数」和「同步函数」都可以实现「异步」，换句话说，「同步函数」也可以进行「异步调用」，例如「多进程」可将「同步函数」封装为任务对象从而实现「异步」（异步调用）；「多协程」可运行「异步函数」从而实现「异步」.




无论通过哪种方式实现「异步（aka. 异步调用）」，都可以总结为

1. 将「同步函数的调用」封装为「任务对象」.
    * async/await 方案
        - `async` 将「同步函数」封装为「协程函数」.
        - 调用协程函数，获取「任务对象」.
        - 调用协程函数是「非阻塞」的，会立刻返回「可等待对象」.
        - 协程方案的「任务对象」，正式叫法是「可等待对象」.
    * Python 多进程/多线程 方案
        - 
2. 运行任务，任务运行期间我们仍然可以做其他事，即「并发/并行」.
    * async/await 方案
        - `await task` 运行任务.
        - `await task` 可看作一个表达式.
        - `await task` 是阻塞式的，但这并不是串行，而是"同时"运行其他任务.
3. 等到任务运行完成，获取运行结果.
    * async/await 方案
        - `await task` 会直接返回运行结果.


「异步（aka. 异步调用）」的一种实现方式

0. 将「同步函数」改写为「异步函数」，因为是改写，所以「互不兼容」.
2. 将异步函数的调用封装为「任务对象」.
3. 批量「创建任务对象」，该操作是「非阻塞」的.
4. 创建一个「事件循环」对象.
5. 将「任务对象」丢进「事件循环」，即「运行任务」，「运行一个任务」会返回一个「返回值对象」（未来对象），该操作是「非阻塞」的.
6. 将「多个」任务对象丢进事件循环，事件循环里存在「多个」任务也就是所谓的「并行/并发」.
6. 「返回值对象」是对异步函数「真正的返回值」的封装.
7. 调用「返回值对象」的内置方法，「主动等待」任务完成，该操作是「阻塞」的.
8. 任务完成，即异步函数执行完.
8. 任务完成时，「真正的返回值」会被「自动」更新进「返回值对象」。用 Go 语言的话来说就是「向 channel 写入内容」.
9. 主动等待了、任务完成了，就可以通过「返回值对象」的内置属性拿到「真正的返回值」，即「回调」。顺便说一句，「async/await」「Promise」出现之前，需要「手动回调」，「手动回调 + 异步函数嵌套」就是所谓的「回调地狱」.

1. 异步函数可以「嵌套」异步函数，「嵌套」即「await」.
7. 异步函数「嵌套（await）」异步函数时，会「自动」将 await 的异步函数调用封装为一个「任务对象」（自动创建任务对象），「自动」将任务对象丢进「事件循环」（自动运行任务）顺便获取「返回值对象」，「自动」调用返回值对象的内置方法来「主动等待」任务完成（自动等待任务完成），「自动」将真正的返回值更新进「返回值对象」，「自动」通过返回值对象的属性拿到「真正的返回值」（自动回调）。这就是为什么 asyncio.run() 只运行了一个异步函数（即一个任务），事件循环里却有多个任务，因为后面的一堆任务都是通过 await 隐式追加的.
8. 「await」做了很多事，自动创建任务、自动运行任务、自动阻塞等待任务完成、自动回调、自动获取真正的返回值，这些都是「自动的」「隐式的」.



asyncio.run() 与 await 之间的调用链的所有函数，都会被 async 关键字污染

「多进程/多线程/多协程」与「事件循环/事件驱动」没有直接联系，「事件循环」只是「多进程/多线程/多协程」的一种实现方式



「高阶函数」指「将函数作为入参の函数」.
「回调函数」指「被传递给高阶函数当入参の函数」.
「回调」分为「同步回调」「异步回调」.
「回调」指「在高阶函数里调用回调函数」？

为什么不直接运行异步函数？为什么要先将异步函数的调用封装为一个任务，然后通过运行任务来运行异步函数？因为 await 是阻塞操作。这导致在 for 循环中调用异步函数的话，全程都是串行。我们这么大力气弄出了 async/await 就是为了让串行变为并行（并发）。异步函数真正的返回值只能通过 await 获取，但是 await 会阻塞，是串行（它本身就是故意这么设计的），也就是说，单单有 await 还没法实现并行/并发。串行变成并行的关键就在于，抽象出了个任务对象，而任务对象的创建操作是非阻塞的。串行是在 for 循环中进行 await，执行完这次才能开始下次调用；并行/并发是通过 for 循环批量创建任务对象，由于任务对象的创建是非阻塞操作，因此批量创建能在一瞬间完成，实现并行/并发的下一步就是让这一堆任务能够同时运行，实现方法有很多，但总结起来就一句话，跑一个事件循环，然后将这堆任务对象全部丢进事件循环，事件循环拿到任务后，会同时运行这些任务，于是串行就变成了并行/并发。至于事件循环是怎么做到同时运行多个任务的，原理比较复杂，我就不多说了，感兴趣的自己去搜。

运行任务为什么不直接返回异步函数的结果？而是返回一个返回值对象，通过返回值对象的属性来获取异步函数的结果？很简单，因为要让获取任务运行结果这个操作（即运行任务这个操作）成为非阻塞操作。

创建任务对象已经是非阻塞了，为什么运行任务这个操作也是非阻塞？仔细想想，我们是怎么实现并行/并发的，没错，是把任务对象丢进事件循环实现的。把任务喂给事件循环，不就是「运行任务」嘛，要想并行/并发，这个操作必须是非阻塞的，这样我们才能让事件循环里同时存在多个任务。如果是运行任务是阻塞的，那事件循环岂不是同一时刻永远有一个任务，不就又成串行了。所以说，不光创建任务对象应该是非阻塞操作，运行任务也应该是非阻塞操作，这样才能实现并行/并发。

运行任务会返回一个返回值对象。

真正的返回值会作为返回值对象的一个属性。

获取返回值对象是非阻塞的。刚拿到返回值对象时，真正的返回值还没被计算出来，但因为是非阻塞的，因此代码会继续运行下去，如果不等待，很可能代码直接跑完了，协程还没运行完，整个程序就退出了。因此我们必须拿到返回值对象之后，主动进行阻塞，等待协程运行完将结果更新到返回值对象，再运行之后的代码。

go 的根本性改革在于，使用通道取代了返回值对象。通道和返回值对象的区别是，返回值对象是在异步函数之外创建的，异步函数无法修改自己的返回值对象。而通道则是可以出现在异步函数的内部，异步函数可以修改通道，也就是把真正的返回值丢进通道。这样的操作堪称神来之笔，通道对象同时存在于异步函数之中和异步函数之外，于是我们可以直接从通道获取返回值，从而避免函数调用链被 async 关键字污染。虽然避免了关键字污染，函数代码还是被破坏了，因为返回值只能通过通道传递，势必要修改函数代码，而且这个函数也不再是同步函数，之前的同步调用要全部修改成操作通道。

通道相比 async/await，本质并没有区别，甚至大部分模型都是一模一样的。很遗憾，污染依旧存在，要想一个同步函数进行异步操作，那么就必须将它改造为异步函数。但是同步函数一旦改造为异步函数，原来的函数调用就不能用了，也必须一并改造为异步函数的调用方式。这样的非兼容的破坏，无论是 async/await 还是通道，都无法避免，都一样。通道语法只不过是更简洁一点，但并没有本质上的优越。

领悟了如此之久，才发现，同步函数与异步函数就是完全不兼容的。这个函数要么是同步函数，要么是异步函数。同步函数不能直接当成异步函数来用，异步函数不能直接当成同步函数来用。这是理论上的不可能。无解。




|          |       多进程        |     多线程     |        多协程        |
| -------- | ------------------- | ------------- | -------------------- |
| 兼容性   | 任何代码            | 任何代码       | 较差，awaitable only |
| 调度方式 | 自动，无法控制       | 自动，无法控制 | await 处             |
| 运行方式 | 并行                | 单核并发       | 单核并发             |
| 适合类型 | CPU bound           | IO bound      | IO bound             |
| 缺点     | 通信繁琐、切换开销大 | 通信繁琐       | 不能直接并发普通函数  |

并发：
「同时」运行多个任务。
并行可以看作是并发。从代码角度，它们差别并不大，它们的区别体现在硬件层面。

如何并发：
Python 实现并发的手段有 多进程 or 多线程 or 多协程 or 三者的组合


并发原理：
不同手段实现的并发，原理并不相同，但可以分为两种。
第一种，并行，原理是多核 CPU 同时运行多个任务，即请多个员工；
第二种，异步，即围棋多面打。
因为原理就这两种，且并发和并行可以区分开来，所以很多时候并发就等于异步。
假设我们有 n 个任务要运行，任务泛指函数、调用 etc。
将 n 个任务放入等待执行队列；
调度器从队列中拿出一个任务，运行；
这个任务运行过程中，遇到了一个费时的操作（阻塞），需要等待一会才能拿到结果，那么调度器会将这个任务挂起，然后从队列拿出一个任务来执行；如果任务阻塞，挂起任务，切换到下一个任务，执行……以此往复；
调度器会实时监视被挂起的任务，任一被挂起的任务拿到结果、不再阻塞，调度器就会切换回这个任务继续执行；
如果执行完一个任务，调度器就从队列拿一个任务执行；
不断重复上述操作，直至完成所有任务。
这也是多进程、多线程、多协程的原理。


并发意义：
一个字，快。
正常情况下写的是同步代码，所有任务是串行的。什么叫串行？运行完这个任务，才会运行下一个任务，运行这个任务的期间，绝不会运行其他任务。因此，运行完所有任务所需的最短时间是每个任务所花费的时间的和。
如果实现了并发，理想情况下，运行完所有任务所需的最短时间是最费时的一个任务所花费的时间。
任务足够多的情况下，并发运行速度是串行的几百几千倍。

OS营造这种假象的技术是『CPU时间共享（time sharing）』，也称为『分时系统』




【异步】

并发、并行、异步、协程、队列、非阻塞の关系：
并发的原理分为两种，并行、异步。

并行一般通过多进程实现，有些语言也支持通过多线程实现并行。所以就有了「多进程（多线程）是并发的手段」这种说法。

异步一般通过协程或多线程实现。
在 Python 中，通过协程来实现异步；
在 Golang 中，通过 channel + goroutine 来实现异步；


「同步」就是完成了当前任务，才能执行下一个任务。
「异步」就是不用执行完当前任务，就能执行下一个任务。过段时间再回来继续执行当前任务。


「队列」是用来解耦的。
「并发」是用来加速的。
队列是队列，并发是并发。
队列可以是串行的，也可以是并发的。
加不加速跟是否使用队列没有关系；
解不解耦跟是否使用异步没有关系；
虽然 python 异步也用到了队列，但它们是完全不同的概念。
队列最核心的用法是「生产者-消费者模型」。
并发最核心的用法是「回调」。
「事件驱动模型」将「回调」与「生产者-消费者模型」结合在一起，实现了「调度」。


「异步」vs「非阻塞」？
首选明确的是，「异步」与「非阻塞」是不同的概念，二者不该被混淆。
代码层面是很难体现出「异步」「非阻塞」之间的区别的，因为都是立刻返回，所以二者经常被混淆。
要想明确区别「异步」与「非阻塞」，必须彻底搞明白「IO 模型」。



【多进程】

pipe只能适用于两个进程间通信，queue则没这个限制
pipe相当于queue的一个子集，只能服务两个进程，pipe的性能高于queue。

一般来说每个进程使用单独的空间，不必加进程锁的，但是如果你需要先实现进程数据共享，又害怕造成数据抢夺和脏数据的问题。就可以设置进程锁




【多线程】

参考

[用户态与内核态 -- 帮你解惑，直达本质 - 掘金](https://juejin.cn/post/6920621924791894023)

[【性能】关于Linux进程的用户态、内核态和内核线程 - 简书](https://www.jianshu.com/p/701c47139781)

[用户级线程和内核级线程，你分得清吗？ - 掘金](https://juejin.cn/post/6844903962504593421)

[一文理解JVM线程属于用户态还是内核态 - 腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1839593)


在 Python 中，多线程与协程的最大区别在于，线程的挂起完全由调度器自动控制，而协程的挂起完全由 await 控制，协程只有运行到 await 处，才会挂起。

多线程的调度器发现运行中的线程如果阻塞，那就将线程挂起，切换到另一个线程。

多协程的调度器发现运行到 await 处，那就将协程挂起，切换到另一个协程。

Python 先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。一切调度都是 Python 根据线程状态控制的，我们无法决定一个线程在何时被调度、何时被挂起（协程就可以）。

继承 Thread 类时，只允许重载 `__init__()` 和 `run()`，不能 override 其他方法。



从根本上说，「进程」是操作系统给「进程模型」提供「并发」能力的手段。

「进程」是为了让 CPU 实现多道编程而发明的一个概念。多道编程，简单说就是「隔离」不相干的任务，但又支持 CPU 多任务并发。

但是进程在一个时间只能干一件事情。如果想同时干两件事，就要创建两个进程；如果其中一个任务需要另一个任务的数据，则必须要进程间通信 Inter-Process Communication (IPC)

「线程」则是为了避免繁琐的 IPC 而诞生的。即在一个进程内并发多个任务。线程模型在进程基础上提供第二次并发。由于线程之间的共享远比进程之间的共享丰富，因此其在需要高度共享的环境下发挥着重要的作用。线程是进程的分身。

内核态线程
用户态线程
还没弄明白……
线程在刚刚出现时，由于无法说服操作系统人员修改操作系统，其实现的方式只能是在用户态。
那么用户态实现意味着什么呢？或者说用户态实现是什么意思呢？就是用户自己做线程的切换，自己管理线程的信息，而操作系统无须知道线程的存在。自己实现线程调度器。
现在许多操作系统都已经支持线程了，OS 会维护一个线程表。


好像搞懂了。
用户态线程是 task，不能直接执行，只能由内核态线程来执行.
多个用户态线程可以共用一个内核态线程，即多路复用.
OS Kernal 提供多个内核态线程，即「内核态线程池」.
跟 golang 的 MPG 调度器有点像，用户态线程对标 goroutine.
用户态线程想要跑必须被调度和某个内核线程绑定，然后内核线程再去竞争cpu资源。
linux 是多对多的模型 M-to-N model
目测，对现在的 OS，用户态线程的调度只能由进程负责，通常就是由进程的主线程负责，使用的是操作系统分配给进程主线程的时间片段；但执行的时候需要


线程诞生之初，OS 还不存在线程，那时的线程更像是现在的协程，调度器也是由程序自己实现，但实际运行的还是进程。
现在的 OS 则不同，已经原生支持线程。实际运行的变成了线程而不是进程，即「线程被包含在进程之中，是进程中的实际运作单位」「线程是资源调度的最小单位」


用户级线程调度器在用户空间的线程库实现，内核的调度对象是进程本身，内核并不知道用户线程的存在。

一个程序至少有一个进程,一个进程至少有一个线程

1. 系统只看到进程看不到用户线程，所以只有一个处理器内核会被分配给该进程 ，也就不能发挥多核 CPU 的优势 。
2. 线程是资源调度的最小单位。

这两句话怎么这么矛盾呢？
既然 OS 看不到用户线程，那为什么线程是资源调度的最小单位呢？
OS 看不到用户线程，那 线程表 和 TCB 是怎么回事呢？
软线程并行又是怎么回事呢？
如果软线程真的不能并行，那 go 的 goroutine 是怎么并行的？
现在的 OS 早就原生支持线程了，那为什么又说「OS 看不到用户线程」？
既然 OS 调度的是进程，那么用户线程到底是怎么被执行的？

我们猜到的比较合理的解释是：

1. 用户线程完全由进程负责 创建、调度、运行、销毁
2. 对于现在的 OS，用户进程、内核进程被调度时，实际上是用户线程、内核线程在执行
3. 所以多用户线程完全由进程中的某个线程（一般是主线程）负责 创建、调度、销毁
4. 用户线程不能直接运行，必须和某个内核线程绑定，然后内核线程再去竞争cpu资源，也就是借助内核线程才能运行

但这么解释又会有一个问题，用户态进程实际是用户态线程在执行，用户态线程实际上是借助内核线程来执行，那么 CPU 就不存在用户态了，所有指令都是内核线程来执行。
显然这个结论是有问题的。


【多协程】

什么时候用协程：
首选多线程。
多线程不好写了，再考虑多协程。
很多库不支持 await，要么阻塞浪费时间，要么自定义协程函数 async def，通过协程函数调用需要的库，也就是自己加一层封装。不过这样的代码不由雅，兼容性差、难以复用、可读性差。宁愿使用多线程牺牲点开销，更由雅、方便复用。

在 Python 中，异步 = 多协程
准确的说，异步和协程是两个概念，在 Python 中，通过协程来实现异步；在 Golang 中，通过 channel + goroutine 来实现异步。

多协程简称协程。
有时候协程对象会被简称为协程。
虽然都叫协程，意思是不同的，注意根据上下文辨别。

Python中的多线程、包括协程，由于CPython的GIL（Global interpreter Lock ，全局解释锁）问题，只能实现并发（Concurrency），不能实现并行（Parallelism）。 因此，在并行计算场景，多进程是Python最简单的选择。

前面提到Python做并行计算的选择，多进程multiprocessing只是最简单的一个选择。 另外还有两个常见选择： 一是使用其它解释器实现的Python，比如PyPy、Jython等； 二是使用C语言优化需要并行的代码，在Native层绕过GIL的限制； 三是使用协程（或线程）加subprocess，这也算是多进程的一个方案。 此外，确认代码是否真的会被GIL所影响，是首要工作。

落：与其 gevnet 打猴子补丁，我宁愿直接多线程，牺牲点速度，换来兼容性、稳定性、低心智负担。

使用Gevent的性能要比传统的线程高，但不得不说的一个坑是如果使用Monkey-patching猴子补丁，Gevent将直接修改标准库中大部分的阻塞式调用，包括`socket`、`ssl`、`threading`、`select`等模块，而变为协作式运行。但无法保证在复杂的生产环境中那些地方使用标准库因补丁而出现的奇怪问题。另外是第三方库的支持，需要确保项目中使用到的其他网络库也必须使用纯Python或明确支持Gevent。

你不 monkeypatch 又有多少程序能支持 gevent 啊。

Monkey-patching。中文「猴子补丁」，常用于对测试环境做一些hack。我个人不太喜欢这种「黑魔法」，因为如果其他人不了解细节，极为容易产生困惑。Gvanrossum说用它就是"patch-and-pray"，太形象了。由于Gevent直接修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。但是我们无法保证你在复杂的生产环境中有哪些地方使用这些标准库会由于打了补丁而出现奇怪的问题，那么你只能祈祷（pray）了。其次，在Python之禅中明确说过：「Explicit is better than implicit.」，猴子补丁明显的背离了这个原则。最后，Gvanrossum说Stackless之父Christian Tismer也赞同他。 我喜欢显式的「yield from」

Monkey-patching猴子补丁是将标准库中大部分的阻塞式调用替换成非阻塞的方式，包括`socket`、`ssl`、`threading`、`select`、`httplib`等。通过`monkey.path_xxx()`函数来打补丁，根据Gevent文档中的建议，应当将猴子补丁的代码尽可能早的被调用，这样可以避免一些奇怪的异常。

Monkey-patching猴子补丁这个叫法源自于Zope框架，大家在修正Zope的Bug时经常会在程序后追加更新部分，这些被称作“杂牌军补丁（guerillapatch）”，后来`guerilla`逐渐写成了`gorllia`（猩猩），再后来就写成了`monkey`（猴子），所以猴子补丁的叫法就这么莫名其妙的得来了。之后在动态语言中，不改变源代码而对功能进行追加和变更就统称为“猴子补丁”。所以猴子补丁并不是Python中专有的，猴子补丁充分利用了动态语言的灵活性，可以对现有语言API进行追加、替换、修改，甚至性能优化等。使用猴子补丁的方式Gevent能够修改标准库中大部分的阻塞式系统调用，包括`socket`、`ssl`、`threading`、`select`等模块，使其变为协作式运行。


根据计算机组成原理，计算机中IO的控制方式包括程序查询方式、程序中断方式、DMA方式、通道方式。目前计算机采用DMA和通道方式进行IO控制，这样在进行IO操作时，CPU可以尽量不参与到这个过程中而去执行其它的操作。由于IO操作一般都比较耗时，采用DMA和通道方式可以将CPU从IO过程中解放出来，从而提高系统的效率。

Python 有 3 种方式实现并发：多进程、多线程、多协程。

Python 中「异步」专指「协程」。

Python 中的协程本质是对「事件驱动」的封装（如对 socket os select queue etc. 的封装）。



「协程」则是为了「手动控制在何处释放 CPU」而生的。无论是进程调度器还是线程调度器，都无法控制在何处会切换，协程调度器只会在 await/channel 处释放 CPU。