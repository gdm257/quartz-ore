---
aliases:
  - Java Specification
tags:
  - flag/MachineLanguage/Programming
  - Label/Industry-工业科学/IT/Language
  - flag/LanguageFeature/if-elif-if
  - flag/LanguageFeature/switch-default
  - flag/LanguageFeature/for-each
  - flag/LanguageFeature/for-loop
  - flag/LanguageFeature/while-loop
  - flag/LanguageFeature/do-while
  - flag/LanguageFeature/try-catch-finally
  - flag/LanguageFeature/pass-by-refference
  - flag/LanguageFeature/function
  - flag/LanguageFeature/class
  - flag/LanguageFeature/interface
  - flag/LanguageFeature/enum
  - flag/LanguageFeature/overload
  - flag/LanguageFeature/decorator
  - flag/LanguageFeature/generic-function
  - flag/LanguageFeature/generic-type
  - flag/LanguageFeature/reflect
  - flag/LanguageFeature/typed
---

# Brief

## References

[Java 全栈知识体系 outline](https://www.pdai.tech/md/outline/x-outline.html)

[Java 全栈知识体系](https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html)

[标准库文档 Java SE 8 API Documentation](https://docs.oracle.com/javase/8/docs/api/)

[JDK 8 Documentation](https://docs.oracle.com/javase/8/docs/)

[JDK 8 Documentation Download](https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html)

[JDK](https://docs.oracle.com/javase/8/)

[Java® SE 8 Language Specification 语言规范](https://docs.oracle.com/javase/specs/jls/se8/html/index.html)

[Java SE Specifications](https://docs.oracle.com/javase/specs/)

[JavaFX 8 API Documentation](https://docs.oracle.com/javase/8/javafx/api/toc.htm)

[Java教程 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744)

[Java W3Cschool](https://www.w3cschool.cn/java/java-inheritance.html)

[Java 菜鸟教程](https://www.runoob.com/java/java-package.html)

[doocs/advanced-java: 😮 Core Interview Questions & Answers For Experienced Java(Backend) Developers | 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识](https://github.com/doocs/advanced-java)

[Snailclimb/JavaGuide: 「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！](https://github.com/Snailclimb/JavaGuide)

[CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计](https://github.com/CyC2018/CS-Notes)

[fuzhengwei/CodeGuide: 本代码库是作者小傅哥多年从事一线互联网 Java 开发的学习历程技术汇总，旨在为大家提供一个清晰详细的学习教程，侧重点更倾向编写Java核心内容。如果本仓库能为您提供帮助，请给予支持(关注、点赞、分享)！](https://github.com/fuzhengwei/CodeGuide)

[Java 笔记 - 知乎专栏](https://www.zhihu.com/column/c_1350258059504144384)

[Archive - Virtual World](https://www.jiaqili.me/post/)

[沉默王二](https://www.itwanger.com/)

[Java学习全攻略-->阅读官方文档 - Van·Zhang - 博客园](https://www.cnblogs.com/LuckyVan/p/9988780.html)

[学习 Java，有什么书籍推荐？学习的方法和过程是怎样的？ - 沉默王二博客](http://www.itwanger.com/java/2020/09/07/java-shuji.html)

[我的第一个真实项目：总结和经验 | ddadaal.me](https://ddadaal.me/articles/summary-of-my-first-real-project)


## Ecosystem

- Ecosystem
    - [Maven Central Repository Search](https://search.maven.org/)
    - [最受欢迎的100个Java库 - 知乎](https://zhuanlan.zhihu.com/p/65329905)

- References
    - [Java 编程 - 2021 开发人员生态系统信息图 | JetBrains: Developer Tools for Professionals and Teams](https://www.jetbrains.com/zh-cn/lp/devecosystem-2021/java/)
    - [Java 编程 - 2020 开发人员生态系统信息图 | JetBrains: Developer Tools for Professionals and Teams](https://www.jetbrains.com/zh-cn/lp/devecosystem-2020/java/)
    - [目前主流的 Java 虚拟机有哪些? - 知乎](https://www.zhihu.com/question/29265430)
    - [Android虚拟机Dalvik和ART - 掘金](https://juejin.cn/post/7089376647576551461)
    - [工具系列：Java 代码规范 (code style + check style) | NingG 个人博客](https://ningg.top//tool-personal-intellij-idea-java-code-style/)
    - [Java Platform SE](https://docs.oracle.com/javase/8/docs/)
    - [JDK 从 1.0 到 JDK11 各版本变化_码农架构 - MdEditor](https://www.mdeditor.tw/pl/ggOM)
    - [Java 14都快出来了，为什么还有那么多人执着于Java 8？ - 知乎](https://www.zhihu.com/question/360985479/answer/1274722961)
    - [关于Open JDK - 知乎](https://zhuanlan.zhihu.com/p/114623519)
    - [AndroidDevTools](https://www.androiddevtools.cn/index.html)
    - [Distribution dashboard  |  Android Developers](https://developer.android.google.cn/about/dashboards/)
    - [AdoptOpenJDK - Open source, prebuilt OpenJDK binaries](https://adoptopenjdk.net)
    - [Stephen Colebourne's blog: Java is still available at zero-cost](https://blog.joda.org/2018/08/java-is-still-available-at-zero-cost.html)
    - [Java extension: Failed to get sources. Instead, stub sources have been generated by the disassembler. · Issue #2277 · redhat-developer/vscode-java](https://github.com/redhat-developer/vscode-java/issues/2277)
    - [Users cannot see the parent pom in remote scenario · Issue #730 · microsoft/vscode-maven](https://github.com/microsoft/vscode-maven/issues/730)
    - [代码质量 - 统一风格：统一代码格式化详解 | Java 全栈知识体系](https://www.pdai.tech/md/develop/ut/dev-qt-code-style.html)
    - [如何将Java打包成exe文件在没有JRE环境的电脑上执行？ - 知乎](https://www.zhihu.com/question/22788689)
    - [关于J2EE和Spring目前到底是怎样的关系，以及未来这两者的发展是怎样的，是否存在竞争市场的情况？ - 知乎](https://www.zhihu.com/question/268742981/answer/341770209)

- Java
    * Specification: Java SE Language Specification
    * Edition: Java SE
    * Version: 8 70%, 11 40%
    * JVM: HotSpot VM
    * JDK: OpenJDK
    * Main: Class `.java` cotaining `main()` method
    * Run: src -> bytecode -(JVM)-> Machine Code
    * REPL: jshell (Java 9+)
    * Project Wizard: Maven
    * Global App Manager: -
    * One-off Runner: -
    * Dependency Manager: Maven
    * Repository: Maven Central Repository (Sonatype)
    * IDE: IDEA
    * Formatter: IDEA + p3c (Alibaba Java Coding Guidelines)
    * Linter:
    * Unit Testing: JUnit
    * Docs:
    * Packing: Maven
    * Builder:
    * CI/CD: Jenkins
    * Tag: OOP, 强类型, VM, Runtime, JIT, AOT, GC
    * Windows Environment: `scoop install -g openjdk9 openjdk8-redhat`
    * Linux Environment: `jenv`

- Main
    * `java Foo` for `Foo.java` class containing `main()` method
        * > [!info]
          > [[ChatGPT]] 在执行一个 Java 类时，如果该类包含了一个名为“main”的 public 静态方法，则该方法会被调用。这是因为在执行 Java 类时，JVM 会搜索该类的 main 方法作为程序的入口点，并执行该方法中的代码。如果该类没有 main 方法，JVM 将无法执行该类，将会出现运行时异常。

- JVM
    - HotSpot VM
    - J9 VM
    - Zing VM
    - JRockit VM
    - Dalvik (Android)
    - ART (Android)

- JDK
    - [AdoptOpenJDK](https://adoptopenjdk.net]
    - [亚马逊 Corretto](https://aws.amazon.com/corretto]
    - [Azul Zulu](https://www.azul.com/downloads/zulu/]
    - [BellSoft Liberica](https://bell-sw.com/java.html]
    - [IBM](https://www.ibm.com/developerworks/java/jdk]
    - [jClarity](https://www.jclarity.com/adoptopenjdk-support/]
    - [Oracle JDK](https://www.oracle.com/technetwork/java/javase/downloads]
    - [Oracle OpenJDK](http://jdk.java.net]
    - [ojdkbuild](https://github.com/ojdkbuild/ojdkbuild]
    - [RedHat](https://developers.redhat.com/products/openjdk/overview]
    - [SapMachine](https://sap.github.io/SapMachine]
    - 鉴于 2019 年 4 月之后 RedHat 从 Oracle 接手了 OpenJDK 的维护工作，不再推荐使用 Oracle 的 JDK Release，无论是商业还是免费，Java SE 还是 Java EE

- JDK Docs
    - Java SE API Documentation
        - 即标准库文档，跟 [[Python|Python]] 标准库文档差不多
        - Java SE API Docs 只占 JDK Docs 的一部分
    - JDK Docs 还包含了方方面面的内容，十分庞杂

- JavaFX
    * Sun 在图形界面的最后一次尝试，称为 JavaFX，最终也失败了

- Swing
    - GUI
    - 比凉的不能再凉了还要凉，纯属浪费时间

- AWT
    - GUI
    - 比凉的不能再凉了还要凉，纯属浪费时间

- applet
    - 凉的不能再凉了
    - applet是只在Web浏览器中运行的小程序，
    - 它是作为网页的一部分而自动下载的（就像网页中的图片被自动下载一样）
    - 当applet被激活时，它便开始执行一个程序
    - 与 js 不同的是，applet 虽然通过浏览器分发，但运行还是依赖于 JRE
    - 早期不少浏览器支持过，包括 IE，但还是太麻烦而被取消支持了

- Java Web Start
    - 凉透了，跟 applet 一样
    - 曾经Java是通过applet以及使用Java Web Start来进行客户端编程的



# 结构化编程
## for

```java
for (int i: intArray) {
    ...
    break;
    continue;
}

for (int i = 0; i<=9; i++) {
    ...
}

do {
    ...
} while (true)

```



## if

```java
if (...) {
    ...
} else if (...) {
    ...
} else if (...) {
    ...
} else {
    ...
}

switch (...) {
    case value01:
        ...
    case value02:
        ...
        break; // 跳出 switch，否则还会继续下一个 case
    case value03:
        ...
    default: // fallback
        ...
}
```

## try

```java
try {
    ...
} catch (Exception01 | Exception02 e) {
    // 一旦匹配，跳过之后的所有 catch
    ...
} finally {
    // 无论是否有异常发生都执行
    ...
}

```



# OOP
## Package

- Philosophy
    - `package com.gdm257.foo.bar`
        - 强烈建议在所有文件中都要使用 `package` 语句来指定所属的包
    - `import` instead of `include`
    - `import pkg.name.ClassName`
        - import type instead of package
        - 不支持 只导入 package
    - `import java.lang.*`
        - 导入包中的所有类，但不包括子包的类
        - 默认自动导入，这就是内置函数、类型的来源
    - `import` 的原理？
        - `CLASSPATH` 对标 [[python command|Python]] 的 `PYTHONPATH`
    1. 查看一个包的子包？
        - [[ChatGPT]]
        - IDE 查看包的目录结构
        - `CLASSPATH` + [[神様のメモ帳/Industry 工业科学/IT/APP/find]] + [[ls]] 查看包的目录结构
    2. 列出已导入的对象？
        - [[jshell]] 中可以使用 `/imports` 指令
        - [[ChatGPT]]
        - 查看源码的 `import` 语句

## Style Guide

[alibaba/p3c: Alibaba Java Coding Guidelines pmd implements and IDE plugin](https://github.com/alibaba/p3c)

[作为良好的 Java 编码规范，可省略的 this 该不该省略？ - V2EX](https://www.v2ex.com/t/425215)

- 命名规笵
    - pkg_name
        - `com/gdm257/myapp/cli/`
    - ClassName/InterfaceName
        - `MyClass.java`
        - `MyInterface.java`
            - `.java` 文件名称 与 类型名称 同名
        - CONSTANT_NAME
        - instanceName
        - ConstructorName
            - 构造方法与类同名
        - methodName
    - 可用字符 `a-zA-Z0-9$_`

入口: `root-folder/src/main/java/com/gdm257/yukihime/yac2lanraragi/xxx.java`
测试: `root-folder/src/test/java/com/gdm257/yukihime/yac2lanraragi/xxxTest.java`
Module: 同根包名
项目根文件夹: 随意

抽象类: Abstract 或 Base 开头
实现类: Impl 结尾
枚举类: Enum 结尾
异常: Exception 结尾
测试类: 同名类 + Test 结尾
如果模块、接口、类、方法使用了设计模式，在命名时要体现出具体模式 OrderFactory
表示类型的名词可以放在词尾，以提升辨识度 E.g. workQueue nameList


Service / DAO 层方法命名规约：
获取单个对象的⽅法⽤ get 做前缀
获取多个对象的方法⽤ list 做前缀，复数结尾 E.g. listObjects
获取统计值的方法⽤ count 做前缀
插⼊入的方法⽤ save/insert 做前缀
删除的方法⽤ remove/delete 做前缀
修改的方法⽤ update 做前缀

领域模型命名规约：
1）数据对象：xxxDO，xxx 即为数据表名。
2）数据传输对象：xxxDTO，xxx 为业务领域相关的名称。
3）展示对象：xxxVO，xxx 一般为网页名称。
4）POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO。

- Manager Layer 基于 Class 进行组织，代码主体也是 Class
- Manager Layer 是 下沉 出来的
- Manager 层不允许**相互**调用，不会出现事务嵌套
- Manager 层提供原子服务接口，Service 层负责依据业务逻辑来调用原子接口


## Variables

### Declare

- 声明
    - `<类型> <变量名>;`
    - 变量必须且只能声明一次
        - 使用 未声明的变量 会报错
        - 重复声明 会报错
    - 类型一旦声明，不可改变

```java
// Declare
String s;
int i;
boolean b;
Cat cat;
```

### Initialize

- 初始化
    - `<变量名> = <表达式>;`
    - 局部变量 不会自动初始化
    - 成员属性 会自动初始化

- 声明 + 初始化
    - `<type> <variable> = <expression>;`

```java
// Initialize
s = "gdm";
i = 257;
b = false;
cat = new Cat();

// Declare & Initialize
String s = "gdm";
int i = 257;
boolean b = false;
Cat cat = new Cat();
```

### Assign

- 赋值
    - `<变量名> = <表达式>;`
    - 此处的 Assign 指再次赋值

```java
// Assign
s = "gdm";
i = 257;
b = false;
cat = new Cat();
```


### Constant

- Constant
    - 

java 有 2 个不要用的关键字 `goto` `const`

常量：固定不变的量

1. 字符串常量 `"sss"`
2. 整数常量 `-257`
3. 浮点数常量 `0.0` `-3.14`
4. 字符常量 `'K'` `'7'` `'魂'`
5. 布尔常量 `true` `false`
6. 空常量 `null`

```java
```

### Type Conversion

- 自动类型转换（隐式）
- 强制类型转换（显式）
- `(目标类型)value`
- 在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开

```java
// Type Conversion
int i = (int)3.14L;

int a = (int)257L;
int a2 = (int)3.14;
Animal a3 = (Animal)Cat();
Cat a4 = (Cat)Animal();






数据类型转换：自动类型转换（隐式）自动完成，数据范围必须从小转到大，如赋的值与声明的类型不一致时。强制类型转换（显式）`int num = (int) 257L`，强制类型转换一般不推荐使用。
```

### Casting

- [[Upcasting]]
- [[Downcasting]]

## Pointer

直接赋值: 标识符是对象の引用，跟 Python 一样.
基本数据类型: 相当于 Python の不可变对象.
引用类型: 相当于 Python の可变对象.
浅拷贝: 跟 Python 一样.
深拷贝: 跟 Python 一样.



**Java 有两种类型，一种是基本类型，一种是引用类型，除了 8 种基本类型之外的全是引用类型。声明为基本类型的变量存储的是值，声明为引用类型的变量存储的是对象的引用。**

所谓引用类型，就跟 Python 的可变对象一模一样。

（引用数据的值为地址，`System.out.println(变量名)` 打印内存地址哈希值）

一个类的成员变量如果是引用类型的话，它的默认值就为 null

null 不是一个有效的对象，所以内存中并没有为它分配空间，没它的位置。null 仅仅是一种表现符号，表明引用此时没有指向任何一个对象。

```java
int a = 257;
int b = a;
b = 255;
System.out.println(a); // a 仍然为 257
```

## int
### 字面量
### 比较
### 分数
### Big Number
### 强制类型转换

```java
类型转换
兼容性


浮点数类型的数值后缀统一为大写的 D 或 F

“类型转换”（Casting）
int i = 200;
long lng = (long)i;
lng = i; // 没有必要的类型提升
long lng2 = (long)200;
lng2 = 200;
// 类型收缩
i = (int)lng2; // Cast required



int i1 = 0x2f; // 16进制 (小写)
System.out.println(
"i1: " + Integer.toBinaryString(i1));
int i2 = 0X2F; // 16进制 (大写)
System.out.println(
"i2: " + Integer.toBinaryString(i2));
int i3 = 0177; // 8进制 (前导0)
System.out.println(
"i3: " + Integer.toBinaryString(i3));
char c = 0xffff; // 最大 char 型16进制值
System.out.println(
"c: " + Integer.toBinaryString(c));
byte b = 0x7f; // 最大 byte 型16进制值  01111111;
System.out.println(
"b: " + Integer.toBinaryString(b));
short s = 0x7fff; // 最大 short 型16进制值
System.out.println(
"s: " + Integer.toBinaryString(s));
long n1 = 200L; // long 型后缀
long n2 = 200l; // long 型后缀 (容易与数值1混淆)
long n3 = 200;

对于 Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。
大写 F 或小写 f 表示 float 浮点数。
大写 D 或小写 d 表示 double 双精度。
十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。
在上例的代码中，char、byte 和 short 的值已经是最大了。如果超过这些值，编译器将自动转型为 int，并且提示我们需要声明强制转换（强制转换将在本章后面定义），意味着我们已越过该类型的范围界限。

Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 _，以使结果更清晰。这对于大数值的分组特别有用。代码示例：

double d = 341_435_936.445_667;
System.out.println(d);
int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111;
System.out.println(Integer.toBinaryString(bin));
System.out.printf("%x%n", bin); // [1]
long hex = 0x7f_e9_b7_aa;
System.out.printf("%x%n", hex);

下面是合理使用的规则：

仅限单 _，不能多条相连。
数值开头和结尾不允许出现 _。
F、D 和 L的前后禁止出现 _。
二进制前导 b 和 十六进制 x 前后禁止出现 _。

float f4 = 1e-43f; //10 的幂数


// int


// long
257L

// short


// float
3.14

// double
3.14F

314E-2


```


## boolean
### bool()
```java


```

### 逻辑运算符

## List
### 字面量
### 拼接
### 增
### 删
### 改
### 切片
### 搜索匹配
### 嵌套
### 属性

typing: `java.util.ArrayList<T>`
定义: 长度不固定、类型固定の列表.

### 强制类型转换

## array[]
### 定义

Array

定义: 长度固定、类型固定の列表.
typing: Object[], 



### 杂

堆中的数组的长度不能改变，所有元素的数据类型相同。

byte[] a;
int[] a;
short[] a;
long[] a;
float[] a;
double[] a;
char[] a;
boolean[] a;
`xxx[]` 可以当成特殊的数据类型，作为方法的入参、出参的类型

数组长度    int len = arrayName.length;
数组遍历    for
数组最值    for + if
数组反转    for


【初始化】

不确定元素内容，用动态初始化；
确定元素内容，用静态初始化；


1. 动态初始化（指定长度，不指定内容）
`int[] arrayA = new int[200];`
`String[] stringA = new String[30]`
`数据类型A[] 数组名称 = new 数据类型B[数组长度];`
或拆分
`int[] arrayA;`
`arrayA = new int[200];`
数据类型A 代表数组的所有元素的数据类型，是统一的
数据类型B 与 数据类型A 保持一致
数组长度 字面意思，是个 int 数字
虽然动态初始化不指定元素的值，但所有元素都有默认值，不同数据类型的默认值不同：
整数型    0
浮点型    0.0
字符串    '\u0000'    这是 1 个 Unicode 字符
布尔型    false
引用型    null


2. 静态初始化（不指定长度，指定内容）
`int[] arrayA = new int[] { 2, 3, 5, 7, 11, 13, 17, 19 };`
`String[] arrayB = new String[] { "Hello", "World" };`
`数据类型A[] 数组名称 = new 数据类型B[] { element01, elment02, ... };`
或拆分
`int[] arrayA;`
`arrayA = new int[] {2,3,5,7};`
或省略格式
`int[] arrayA = { 2, 3, 5, 7, 11, 13, 17, 19 };`
`String[] arrayB = { "Hello", "World" };`
`数据类型A[] 数组名称 = { element01, elment02, ... };`
数组有长度。静态初始化的数组虽然没有直接指定长度，但根据指定的内容，可以推算出数组长度。





【元素访问】

`arrayName[3]`
`arrayName[indices]`
`System.out.println(arrayName[0]);`

注意了，java 索引值从 0 开始，所以 `arrayName[3]` 是第 4 个元素。而 Matlab 索引值从 1 开始；



【元素赋值】

`arrayName[0] = 15;`
`arrayName[indices] = 15;`


java.util.Arrays 类能方便地操作数组






## set

### 字面量
### 集合推导式
### 拼接
### 强制类型转换
### 增
### 删
### 搜索匹配
### 属性


## dict

### 字面量
### 字典推导式
### 增
### 删
### 索引
### 改
### 合并
### 搜索
### 属性
### 嵌套
### 强制类型转换
### 有序字典

Map


## class

《On Java 8》

### `instanceof`

- `instanceof` 操作符返回 `true` 或 `false`
- 需要注意的是，我们在使用  instanceof  操作符之前，需要先确定这个对象是否为 null。否则，尝试将一个 null 对象转换为字符串类型，会导致空指针异常。

```java
if (object instanceof SomeClass) {
    // 对象是 SomeClass 的一个实例
}

if (object instanceof SomeInterface) {
    // 对象实现了 SomeInterface 接口
}

```

### 魔法方法

```java
public class MagicClass {

    public 

}

```

### 容器
### 类成员

1. 导包 `import 包名.类名;`
2. 实例化 `ClassName objectName = new ClassName();`
3. 调用 `对象名.成员名`

类 = 成员变量 + 方法 + 内部类 + 接口 + 枚举
普通的类 `public class ClassName {}`
接口实现类 `public class ClassName implements InterfaceName {}`
抽象类 `public abstract class MethodName {}`
子类 `public class SubclassName extends SupperclassName {}`
匿名类 `object01 = new Type(parameterList)`
成员内部类（类中类）
局部内部类（方法中的类）
包装类




局部变量：方法中的变量，作用域为该方法
成员变量：类中但在方法外的变量（且没用 static 修饰），相当于 [[C-Sharp|C#]] 的实例字段。实例初始化时才 Initialize
静态变量：用 static 关键字声明的成员变量（类变量），相当于 [[C-Sharp|C#]] 的类字段。类初始化时就 Initialize 了
变量作用域：声明那行开始，所属代码块的反大括号那行结束



### 万能类型 (Object)

所有的 class 最终都继承自 `Object`，即单根继承。

Object 定义了几个重要的方法

- `toString()`：把instance输出为`String`；
- `equals()`：判断两个instance是否逻辑相等；
- `hashCode()`：计算一个instance的哈希值。

自从 C++ 引入以来，一个 OOP 问题变得尤为突出：是否所有的类都应该默认从一个基类继承呢？这个答案在 Java 中是肯定的（实际上，除 C++ 以外的几乎所有OOP语言中也是这样）。在 Java 中，这个最终基类的名字就是 `Object`。

这被称为「单继承结构」。



### 构造器 (Constructor)
### 初始化

参考

[Java类的初始化顺序 - 知乎](https://zhuanlan.zhihu.com/p/354294187)[Java类的初始化顺序 - 知乎](https://zhuanlan.zhihu.com/p/354294187)


### 修饰符

访问修饰符：

`public`
`private`
`protected`
`default`（即默认，什么也不写）


非访问修饰符：

`static`
`final`
`abstract`
`synchronized`
`native`
`strictfp`
`transient`
`volatile`


### 继承


继承 `public class SubclassName extends SuperclassName {}`

### 组合+委托
### 多态

参考

[Java：多态乃幸福本源 - 沉默王二博客](https://www.itwanger.com/java/2019/11/06/java-duotai.html)

[Java多态详解及对象的向上转型、向下转型 - sun10367 - 博客园](https://www.cnblogs.com/sun10367/p/13561193.html)

[多态中的向上转型与向下转型 - 知乎](https://zhuanlan.zhihu.com/p/354294694)

[深度分析：理解Java中的多态机制，一篇直接帮你掌握！ - SegmentFault 思否](https://segmentfault.com/a/1190000022705651)


多态的存在有三个前提:
1.要有继承关系
2.子类要重写父类的方法
3.父类引用指向子类对象 `BaseClass newObject = new SubClass();`

向底层转型（向上转型）`BaseClassName objectName = new SubClassName();`
向表层转型（向下转型）`SubClassName objectName = new BaseClassName();`


### 内部类

参考

[Java内部类 - 沉默王二博客](https://www.itwanger.com/java/2019/11/07/java-inner-class.html)


```java

class MyClass {
    MyClass(int arg01, int arg02) {
        // java 将与类同名的方法作为该类的 Constructor
        // 构造器也称构造方法，但不需要声明返回值类型，也不需要 return
        // Constructor 可以添加 访问权限修饰符，但 public 是无效的，
    }
}



所有的覆写方法，必须加 @Override 注解
相同参数类型，相同业务含义，才可以使用的可变参数，参数类型避免定义为 Object




{None,public,private,protected}    访问权限修饰符
static    静态修饰符
final    常量修饰符，相当于 const
abstract    抽象类
class MyClass {}
extends A, B, C
implements A, B, C
throws


default (package)
没有权限修饰符，则使用默认权限，即只有同一个 package 内的类可以访问。


private
关键字 private 意味着除了包含该成员的类，其他任何类都无法访问这个成员。同一包中的其他类无法访问 private 成员，你可以自由地修改那个被修饰的成员，无需担心会影响同一包下的其他类。

为了清晰起见，你可以采用一种创建类的风格：public 成员放在类的开头，接着是 protected 成员，包访问权限成员，最后是 private 成员。


```




### 抽象类

普通的类没有抽象方法；
抽象类有抽象方法；
接口全是抽象方法。


## interface

[Java基础知识系列4：抽象类和接口 - Virtual World](http://www.jiaqili.me/post/java-basics-4-interface/)


接口方法签名 void commit();
接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。

接口基础常量 String COMPANY = "alibaba";
尽量不要在接口里定义常量，如果一定要定义，最好确定该常量与接口的方法
相关，并且是整个应用的基础常量。


**接口本质上是允许多继承的纯抽象类。**

接口 `public interface InterfaceName {}`


## Object

万能数据类型 `Object`

## enum

[秒懂系列，超详细Java枚举教程！！！ - 何学长在奔跑 - 博客园](https://www.cnblogs.com/ziph/p/13068923.html)

- 虽然 `enum` 是一个保留关键字，但 Enum 类型目测只是特定 `class` 的语法糖


### 定义

定义: 一组常量.


```java

public enum Color {
    R, // 全大写
    G,
    public static final B // 成员权限始终默认为 public static final
}

Color r = Color.R;
int rNum = r.ordinal();
Color[] r = Color.values(); // 不确定是否是数组，总之可迭代
for (Color c: Color.values()) {
    ...
}


```


### 作用

作用: 避免硬编码、代码可读性.




## 泛型

泛型在 Java 5 出现，泛型编程（Generic Programming）是一种语言机制，通过它可以实现一个标准的容器库。

像类一样，泛型也是一种抽象数据类型，但是泛型不属于面向对象，它是面向对象的补充和发展。




## RAM

参考

《On Java 8》Chapter 06. Housekeeping





## 生命周期




# FP

## lambda

## function()

[Lambda表达式详解 - 知乎](https://zhuanlan.zhihu.com/p/356270538)

[Java高阶函数 - 知乎](https://zhuanlan.zhihu.com/p/357918015)


- 可变长参数列表
- lambda
- 高阶函数
- 抽象方法

```java

func01(Object... args) {
    // args 作为一个数组来解析
}


```

「->」是匿名函数 lambda 表达式的写法

方法 `修饰符 返回值类型 方法名(参数类型 参数名, ...) {return 返回值;}`
普通方法 `public static void methodName() {}`
成员方法 `public void methodName() {}`
抽象方法 `public abstract void methodName() {}`
？？？静态方法 `methodName`
main 方法 `public static void main(String[] args) {}`
调用 `ClassName.methodName( 2, 5, 7, ... )`
Lambda 本质上是种匿名方法
（方法定义总是在类中）
（方法不能直接嵌套方法）
（声明成员方法可以省略 public）
修饰符：现阶段固定写法 `public static`
返回值类型：四类八种(`byte int short long float double char boolean`) or `void` or `type[]`（e.g. 整数型数组写 `int[]` 二维整数型数组 `int[][]` 其他数组依此类推）
`void` 表示没有返回值（no return）
类可以有两种类型的方法：实例方法和类方法。实例方法和类方法也分别称为非静态方法和静态方法。
实例方法用于实现类的实例的行为。实例方法只能在类的实例的上下文中调用。
类方法用于实现类本身的行为。类方法总是在类的上下文中执行。
静态修饰符用于定义类方法。方法声明中缺少静态修饰符，使得​​该方法成为一个实例方法。

class 关键字：⽤用于在 Java 中声明⼀一个类。
public 关键字：⼀一个表示可⻅见性的访问修饰符。
static 关键字：我们可以⽤用它来声明任何⼀一个⽅方法，被 static 修饰后的⽅方法称之为静态⽅方法。静态方法不不需要为其创建对象就能调⽤用。
void 关键字：表示该方法不返回任何值，而是方法自己打印输出，如果方法定义了的话。无返回值的方法只能直接调用，不能打印调用、赋值调用。
main 关键字：表示该⽅方法为主⽅方法，也就是程序运⾏行行的⼊入⼝口。 main() ⽅方法由 Java 虚拟机执⾏，配合上 static 关键字后，可以不不⽤用创建对象就可以调⽤用，可以节省不不少内存空间。

【方法调用】

1. 单独调用 `methodName(args);`
2. 打印调用 `System.out.println(methodName(args));`
3. 赋值调用 `xxx = methodName(args);`

有返回值的方法可以直接调用、打印调用、赋值调用；
无返回值的方法（void）只能直接调用，不能打印调用、赋值调用。



【方法重载】

方法可以接受不同个数的参数。
e.g. sum(a,b) sum(a,b,c)
参数列表有几种，需要定义几次方法，每次的 methodName 相同，args 不同。
调用时程序会自动判断应该用哪种 args。

`public static int sum(int a, int b) { return a+b; }`
`public static int sum(int a, int b, int c) { return a+b+c;}`
`System.out.println(sum(10,20))`
`System.out.println(sum(10,20,30))`



## @decorator


## 反射

## 注解


## 运算符

```java

instanceof    "abc" instanceof String
instanceof()
new
布尔表达式 ? 值1 : 值2    if-else 三元运算符


+
-
*
/
%


Math.pow(x,n)    x的n次方
=
+=
-=
*=
/=
%=
i++
i--
++i
--i


>
<
>=
<=
==
!=
<<=
>>=
>>>=


&&    逻辑与
||    逻辑或
!    逻辑非
∧    逻辑异或


&    短路与
|    短路或
<<    左移
>>    右移
>>>    无符号右移





```



## // 注释

```java
// 单行注释

/* 多行注释
多行注释
*/


/**
* 一句话简介
*
* javadoc
* 文档注释
*/


/**
* 通用注释
*
* @author gdm257
* @version 版本说明
* @date 2022/1/1
* @since 从哪个版本开始引入，比如 version 0.7.0
* @see 
* @link 
* @description balabala
*
* @classname MyClass
*
* @param arg01 这个参数的说明
* @return 返回值的说明
* @throw
*/

/**
* 一句话简介
*
* @classname PearlMilkTea
* @author gdm257
* @date 2022/1/1
* @version 版本说明
* @since 从哪个版本开始引入，比如 version 0.7.0
* @param arg01 这个参数的说明
* @return 返回值的说明
* @throw
* @see https://...
* @link https://...
*/


```

单行注释 `//单行注释`
多行注释 `/*多行注释*/`
文档注释 `/**文档注释*/` ⽤在类、字段、方法
使用 Javadoc 生成文档


```java
// 多行注释

/*
123
abc
*/
```



```java
// 方法注释
/**
 * @param num1: 加数1
 * @param num2: 加数2
 * @return: 两个加数的和
 */
public int add(int num1,int num2) {
    int value = num1 + num2;
    return value;
}



// 类注释
/**
 * @projectName（项目名称）: project_name
 * @package（包）: package_name.file_name
 * @className（类名称）: type_name
 * @description（类描述）: 一句话描述该类的功能
 * @author（创建人）: user 
 * @createDate（创建时间）: datetime  
 * @updateUser（修改人）: user 
 * @updateDate（修改时间）: datetime
 * @updateRemark（修改备注）: 说明本次修改内容
 * @version（版本）: v1.0
 */
public class student{
    .................
}
```



## 行尾分号;

- 所有 Java 语句以分号 `;` 结尾，除了花括号 `{}` 代码块


## 逻辑行

- 一个逻辑行，可以直接写成多个物理行，也就是说，可以把换行当空格使，因为 Java 有行尾分号，非常方便



# 结构化并发
## 并发
