---
aliases:
  - Python
  - Python Specification
tags:
  - flag/MachineLanguage/Programming
  - Label/Industry-工业科学/IT/Language
  - flag/LanguageFeature/if-elif-if
  - flag/LanguageFeature/switch-default
  - flag/LanguageFeature/for-each
  - flag/LanguageFeature/while-loop
  - flag/LanguageFeature/try-catch-finally
  - flag/LanguageFeature/with
  - flag/LanguageFeature/pass-by-refference
  - flag/LanguageFeature/function
  - flag/LanguageFeature/class
  - flag/LanguageFeature/generic-function
  - flag/LanguageFeature/generic-type
  - flag/LanguageFeature/decorator
  - flag/LanguageFeature/await
  - flag/LanguageFeature/yield
  - flag/LanguageFeature/typed
  - flag/LanguageFeature/reflect
extensions:
  - .py
  - .pyc
files:
  - __init__.py
keywords:
  - pass
  - for
  - in
  - while
  - continue
  - break
  - if
  - match
  - case
  - try
  - except
  - finally
  - raise
  - assert
  - else
  - def
  - lambda
  - async
  - await
  - yield
  - return
  - from
  - import
  - as
  - global
  - nonlocal
  - with
  - type
  - class
  - is
  - del
operators:
  - +
---

# Brief

## References

- Objects
    - [术语对照表 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/glossary.html)

- API
    - [Python标准库之一句话概括 - 知乎](https://zhuanlan.zhihu.com/p/37240446)
    - [PEP 594: Python 3.13 removes 20 stdlib modules](https://discuss.python.org/t/pep-594-has-been-implemented-python-3-13-removes-20-stdlib-modules/27124)

- Shortcut
    - [The Best Python Cheat Sheet](https://kieranholland.com/best-python-cheat-sheet/)

- Ecosystem
    - General
        - [ml-tooling/best-of-web-python](https://github.com/ml-tooling/best-of-web-python)
        - [Awesome python Stats](https://emanuelef.github.io/awesome-python-repo-stats/)
        - [jobbole/awesome-python-cn](https://github.com/jobbole/awesome-python-cn)
        - [krzjoa/awesome-python-data-science](https://github.com/krzjoa/awesome-python-data-science)
        - [Python 模块收集](https://blog.konghy.cn/2017/04/04/python-modules/)
        - [这几天加班熬夜把所有Python库整理了一遍，非常全面！](https://zhuanlan.zhihu.com/p/98366871)
        - [sindresorhus/awesome](https://github.com/sindresorhus/awesome)
   - Analyst
        - [thuquant/awesome-quant: 中国的Quant相关资源索引](https://github.com/thuquant/awesome-quant)
        - [wilsonfreitas/awesome-quant: A curated list of insanely awesome libraries, packages and resources for Quants (Quantitative Finance)](https://github.com/wilsonfreitas/awesome-quant)
        - [Python可视化笔记43篇合集（建议收藏） - 知乎](https://zhuanlan.zhihu.com/p/313462427)
        - [Python Graph Gallery](https://python-graph-gallery.com/)
        - [Full Stack Python](https://www.fullstackpython.com/)
        - [AllenDowney/ThinkDSP: Think DSP: Digital Signal Processing in Python, by Allen B. Downey.](https://github.com/AllenDowney/ThinkDSP)
        - [Python for Data Analysis, 3E](https://wesmckinney.com/book/)
        - [bharathgs/Awesome-pytorch-list](https://github.com/bharathgs/Awesome-pytorch-list)

- References
    - Python Enhancement Proposals
        - [PEPs](https://peps.python.org)
        - PEP    **深入**理解 Python 的绝佳资料
        * PEP 0    Index of PEPs
        * PEP 3000    Python 3000
        * PEP 8000    Python Language Governance Proposal Overview
        * 特性
        * PEP 435    Adding an Enum type to the Python standard library    `Enum`
        * PEP 484    Type Hints
        * PEP 561    Distributing and Packaging Type Information
        * PEP 498    Literal String Interpolation    `f-string`
        * PEP 443    Single-dispatch generic functions    泛型
        * PEP 515    Underscores in Numeric Literals    数字下划线
        * PEP 526    Syntax for Variable Annotations
        * PEP 557    Data Classes
        * PEP 646    Variadic Generics
        * PEP 3129    Class Decorators
        * PEP 3132    Extended Iterable Unpacking    动态解包
        * PEP 3156    Asynchronous IO Support Rebooted: the “asyncio” Module
        * PEP 572    Assignment Expressions    `:=` 垃圾语法糖
    - 500 Lines or Less
        - 非常有水平
        - [HT524/500LineorLess\_CN: 500 line or less 中文翻译计划。](https://github.com/HT524/500LineorLess_CN)
        - [aosabook/500lines: 500 Lines or Less](https://github.com/aosabook/500lines)
    - The Python Tutorial
        * The Python Tutorial 官方教程，绝对是最佳的巩固基础的教程，没有之一.
        * The Python Tutorial 极多细节，但绝不是细枝末节，这些都是真正的基础！
        * The Python Tutorial 不适合新手，只适合进阶、检验水平.
        * The Python Tutorial 不能三个小时内全部读懂，不能算 Python 高手.
        * The Python Tutorial 我陆陆续续读了好几遍，才全部读懂.
        - [The Python Tutorial](https://docs.python.org/3/tutorial/index.html)
    - 一位 Pythonista 的经验分享
        - 入门之后的下一步
        - [piglei/one-python-craftsman: 来自一位 Pythonista 的编程经验分享，内容涵盖编码技巧、最佳实践与思维模式等方面。](https://github.com/piglei/one-python-craftsman)

- Examples
    - [xianhu/LearnPython: 以撸代码的形式学习Python](https://github.com/xianhu/LearnPython)
    - [Real Python](https://realpython.com/)
    
    - [Yixiaohan/show-me-the-code: Python 练习册，每天一个小程序](https://github.com/Yixiaohan/show-me-the-code)
    - [jackzhenguo/python-small-examples: 告别枯燥，致力于打造 Python 实用小例子，更多Python良心教程见 Python中文网 http://www.zglg.work](https://github.com/jackzhenguo/python-small-examples)
    - [Python-World/python-mini-projects: A collection of simple python mini projects to enhance your python skills](https://github.com/Python-World/python-mini-projects)
    
    - [Python Cookbook 3rd Edition Documentation 中文版](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html)
    - [gto76/python-cheatsheet: Comprehensive Python Cheatsheet](https://github.com/gto76/python-cheatsheet)

- References
    - [Kirigaya的Python实验室 - 知乎](https://www.zhihu.com/column/c_1344639277142183936)
    - [(译)Python Database API 规范 2.0 | SinHub's Blog](https://sinhub.cn/2019/01/pep249-in-chinese/)
    * PEP 3333    Python Web Server Gateway Interface v1.0.1    WSGI
    * PEP 333    Python Web Server Gateway Interface v1.0    WSGI
    * PEP 249    Python Database API Specification v2.0
    * PEP 405    Python Virtual Environments
    * PEP 582    Python local packages directory    `__pypackages__`
    * PEP 517    A build-system independent format for source    前后端
    * PEP 518    Specifying Minimum Build System Requirements for Python Projects    `pyproject.toml`
    * PEP 427    The Wheel Binary Package Format 1.0    `.whl`
    * PEP 376    Database of Installed Python Distributions    `.dist-info`
    * PEP 441    Improving Python ZIP Application Support    `.pyz`
    * PEP 517    A build-system independent format for source trees
    * PEP 621    Storing project metadata in pyproject.toml

## Edition

- Idea
    - Python 3.7
        - Python 离完美只差 2 步
        - 删除 `:=`
        - 删除 `match-case`
        - 所以 Python 3.7 是艺术品

- References
    * PEP 478    Python 3.5 Release Schedule
    * PEP 494    Python 3.6 Release Schedule
    * PEP 537    Python 3.7 Release Schedule
    * PEP 569    Python 3.8 Release Schedule
    * PEP 596    Python 3.9 Release Schedule
    * PEP 619    Python 3.10 Release Schedule
    * PEP 664    Python 3.11 Release Schedule
    * PEP 693    Python 3.12 Release Schedule
    * PEP 719    Python 3.13 Release Schedule
    * [Python 编程 - 2021 开发人员生态系统信息图 | JetBrains: Developer Tools for Professionals and Teams](https://www.jetbrains.com/zh-cn/lp/devecosystem-2021/python/)
    - [Python 编程 - 2020 开发人员生态系统信息图 | JetBrains: Developer Tools for Professionals and Teams](https://www.jetbrains.com/zh-cn/lp/devecosystem-2020/python/)

## Philosophy

- References
    - PEP 20    The Zen of Python
    * PEP 8    Style Guide for Python Code
    * PEP 287    reStructuredText Docstring Format
    * PEP 257    Docstring Conventions
    - [Python风格规范 — Google 开源项目风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/)
    - [Python 项目工程化开发指南](https://pyloong.github.io/pythonic-project-guidelines/)
    - [Python 为什么？chinesehuazhou/python-whydo: Explore Python's charms by asking WHY questions](https://github.com/chinesehuazhou/python-whydo)
    - [Designing Pythonic library APIs](https://benhoyt.com/writings/python-api-design/)
    - [浅谈 Python 库的插件系统设计 | Frost's Blog](https://frostming.com/2020/03-16/plugin-system-1/)
    - [浅谈 Python 库的插件系统设计2 | Frost's Blog](https://frostming.com/2020/03-16/plugin-system-2/)
    - [插件化 - Python 项目工程化开发指南](https://pyloong.github.io/pythonic-project-guidelines/guidelines/advanced/plugin/)

- Philosophy
    - The Zen of Python
        - There should be one-- and preferably only one --obvious way to do it. —Tim Peters

- Test
    - forced 禁止使用 `match-case`
    - forced 禁止使用 `:=`

### Project Layout

- `<project root>/`
    - `src/`
        - `<my_module_01>/`
        - `<my_module_02>/`
            - `__init__.py`
            - `__main__.py`
            - API Layer
            - `cli/`
            - `tui/`
            - `gui/`
            - `api/`
                - 应保持独立
                - 不应该对 `controller`/`server` 有任何依赖
                - 通过 [[Dependency Inject|DI]] 可以使 `api` 无需显式依赖 `service`
            - `server/`
            - `spider/`
            - BIL
            - `service/`
                - BIL 入口
                - 接口定义层
                - 稳定的 入参、返回值 or 属性
            - `logic/`
                - 最复杂的部分
            - DAL
            - `model/`
            - Underlying
            - `log/`
            - `conf/`
            - `contrib/`
    - `tests/`
        - `__init__.py`
    - `notebooks/`
    - `reports/`
    - `scripts/`
    - `pyproject.toml`
    - [[EditorConfig|.editorconfig]]
    - `LICENSE`
    - `README.md`
    - `CONTRIBUTING.md`
    - `CHANGELOG.md`

## DSL
    
- DSL
    - [10. 完整的语法规范 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/reference/grammar.html)
    - [Python 语言参考手册 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/reference/index.html)

- Philosophy
    - Language Specification
        1. Keywords
        2. Macros
        3. Symbols
        4. Literals

- python 目录结构可以随心所欲，爱咋咋地
    - python 入口文件必须手动指定
    - python 要导入模块会在 `sys.path` 下寻找

- `.py` 文件是一个 module（模块）
- 带 `__init__.py` 的文件夹是一个 package
- package 是种特殊的 module
- 任何具有 `__path__` 属性的 Module 都会被当作是 Package
- package 可以拥有 submodule，而普通 module 不能拥有 submodule

python 比较懒，「语言规范」与「编译器」是一体的，而不是分开的。

什么叫「语言规范」与「编译器」分开？什么叫不分开？

举个例子，JavaScript 这门语言，它的「语言规范」也就是「ECMA」，专门负责「设计」，包括但不限于「JS 是一个什么样的语言」「JS 有哪些语法」等等。而 JS 的「编译器」是「V8」，V8 是语言规范的一种实现，既然是实现，那么理论上有多种实现，是的，除了 V8，还有其他 JS 编译器实现，例如 Firefox 用的引擎。

C#/Java 跟 JS 差不多，Java 的语言规范是 Java SE，而实现是各种 JVM。甚至连 C/C++ 也是这样。

Python 就很不同。Python 并没有将「语言规范」独立出来，而是利用 CPython 这个编译器支持的语法，来定义什么是 Python 的语法规范。

「CPython 能解析哪些语法、支持哪些语言特性，我全写编译器里了，哝，这些就是 Python 的语言规范，如果你想自己写个 Python 编译器，自己照着 CPython 看吧」

所以你能看到 MicroPython、Jython 等编译器说自己兼容 CPython，实际上就是在说我实现了 Python 的语法规范。当然二者并发完全等价，现实中两个编译器总有不兼容的地方，严格来说，CPython 以外的编译器，只要不是 100% 兼容，都算是 Python 方言，哪怕你 99.999% 兼容 CPython。

「语言规范」没有独立，可能造成语言停滞不前。但好在 Python 有 PEP，即 Python 增强提案，想新增什么语法？什么特性？在发起一个 PEP 就是了，如果大家都觉得不错，CPython 实现了、提案通过了，那么这个 PEP 就算是新的语法规范的一部分了。

确实省事，而且 PEP 门槛低，能充分发挥社区的力量，很符合 Python 的风格。

## Fundamentals

[CPython source code](https://devgui
[Python的幕后#1: CPython VM 是如何工作的 - 世界的过客](https://laujay.com/posts/how-the-cpython-vm-works/)

[Python的幕后#2: CPython 编译器是如何工作的 - 世界的过客](https://laujay.com/posts/how-the-cpython-compiler-works/)

[Python 幕后解释器：一系列的学习资源](https://mp.weixin.qq.com/s/Q6NXkzzgWT2qsCM5k669iQ)

[CPython Internals 笔记 ── Python 语言和语法 · QIWIHUI](https://qiwihui.com/qiwihui-blog-149/)

[Python深入探究(一)Python编译方法 | One day, New day.](https://qinzheng7575.github.io/2021/02/18/Python_1_compile/)

[《深入Python虚拟机》笔记4-编译Python源代码 - 知乎](https://zhuanlan.zhihu.com/p/33838527?utm_id=0)

[【译】Python 幕后 #1: CPython 虚拟机如何工作](https://www.linuxzen.com/python-behind-the-scenes_1_how_cpython_vm_works.html)

[(译)Python 垃圾回收实现 - CPython, PyPy 以及 GaS | SinHub's Blog](https://sinhub.cn/2017/11/chinese-translation-of-python-gc-final-2012-01-22/)

[Python之父：Python 4.0可能不会有了_语言 & 开发_TecTalk_InfoQ精选文章](https://www.infoq.cn/article/19ulbxy0xy7cebazog2x)

[性能调优工具 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AF%87/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7.html)
de.python.org/internals/exploring/)

- Architecture
    - src -> bytecode -(interpreter)> execute
    - JIT: src -> bytecode -(CPython)> machine code -> execute
    - [Python3.13的JIT是如何实现的 - 知乎](https://zhuanlan.zhihu.com/p/682997904)

## Ecosystem

[10. 完整的语法规范 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/reference/grammar.html)

[PythonImplementations - Python Wiki](https://wiki.python.org/moin/PythonImplementations?action=show&redirect=implementation)

[Python 项目工程化最佳实践指南](https://www.qin.news/python/)

[Python打包指南2021 | Frost's Blog](https://frostming.com/2020/12-25/python-packaging/)

[你的 Python 包都装到哪了？ | Frost's Blog](https://frostming.com/2019/03-13/where-do-your-packages-go/)

[Python 打包的现状：包的三种类型](https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&mid=2247485029&idx=1&sn=a986bf7b7d7003f637cfccc6428e6310&scene=21#wechat_redirect)

[Python 官方团队在打包项目中踩过的坑](https://mp.weixin.qq.com/s/Kmqhr9szPdvBI0KQPm9JsA)

[Python 打包——过去、现在与未来](https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&mid=2247485034&idx=1&sn=b4a039013e3265c04700c48b1b338e06&scene=21#wechat_redirect)

[PyCon China 2021 演讲——Python 打包 101 | Frost's Blog](https://frostming.com/2021/10-20/pycon-china-2021/)

[Python 包装的概述 — Python Packaging User Guide](https://daobook.github.io/packaging.python.org/overview.html)

[Python Packaging User Guide — Python Packaging User Guide](https://packaging.python.org/en/latest/)

[分发 Python 模块 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/distributing/index.html)

[zipapp —— 管理可执行的 Python zip 打包文件 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/zipapp.html)

[PEP 441 – Improving Python ZIP Application Support | peps.python.org](https://peps.python.org/pep-0441/)

[Debian 系统上捉摸不定的 Python | Frost's Blog](https://frostming.com/2022/03-27/python-on-debian/)

[Python安装目录下Scripts/里的exe文件 - 知乎](https://zhuanlan.zhihu.com/p/360502932)

- Python
    * Specification: CPython
    * Version: 3.7
    * Interpreter: CPython
    * Main: `python xxx.py` line by line
    * Run: src -(Interpreter)-> Machine Code
    * REPL: `python`
    * Windows: `scoop install python37`
    * Linux: pyenv
    * Running Environment: virtualenv
    * Dependency Manager: pdm
    * Repository: PyPi
    * Project Wizard: cookiecutter
    * Global App Manager: pipx
    * One-off Runner: pipx
    * IDE: PyCharm/IDEA
    * Formatter:
        * Black + isort + docformatter
        * black + ruff
        * **ruff**
    * Linter: Flake8 + Mypy + bandit
        * ruff + mypy + bandit
        * **ruff + mypy**
    * Docs: Sphinx + ReadtheDocs
        * 
    * Unit Testing: pytest
    * Application Testing: 
    * Multiple Environments Testing: tox
    * Packing: pyproject.toml + pdm + pdm-backend + wheel
        - Config: pyproject.toml
        - Build Frontend:
            - pdm
            - poetry
            - pip
        - Build Backend:
            - pdm-backend
            - ~~pdm-pep517~~
            - flit
            - setuptools
        - Package:
            - wheel
            - ~~egg~~
    * Publish: pdm
    * Builder: nuitka, pyinstaller
    * CI/CD: 
    * Tag: OOP, 脚本, 解释型, 弱类型, 动态, GC, Runtime

- Python Environment
    1. Simple Interpreter (System Interpreter)
    2. Pipenv Environment
    3. **Virtualenv Environment**
    4. Conda Environment
    5. PEP 582
    - Python Environment 是用来运行 Python 脚本的，仅此而已
    - Python Environment 准确的说是一种规范，而不是具体的软件。PEP 582 完美地体现了这点，任何实现了 PEP 582 的软件都能管理 PEP 582 所定义的 Python 环境。
    - 一个软件可以支持一种或多种 Python 环境，这要看开发者的设计。例如 pdm 和 pipx 就同时支持 PEP 582 和 virtualenv。pyenv 支持 pipenv 和 virtualenv。而 venv 只支持 virtualenv 环境。
    - 与其比较 poetry/pdm etc 包管理工具的不同，不如先了解各个 Python 环境的基本原理，这样才能真正理解如何选择。

- Python Environment Manager
    - Global Environment
        - [[scoop]] (Recommanded for Windows)
        - [[pyenv]] (Recommanded for Linux)
        - [[virtualenvwrapper]] (Recommanded for Windows)
        - `conda`
    - Project Environment
        - [[poetry]]
        - [[pdm]]

- Package Manager
    - Global
        - [[pip]]
        - [[pipx]]
    - Project
        - [[poetry]]
        - [[pdm]]

- Package Management
    * 结论
        Linux: python管理 pyenv, 其他管理 pipx + pdm
        Windows: python管理 scoop
                 其他管理 pipx + pdm + virtualenvwrapper
                 virtualenvwrapper 使用 scoop 下载的 interpreter
    * `pipx`    下载 GUI/CLI
    * `pdm`    项目包管理，效果同 node npm/yarn
    * `virtualenvwrapper`
        * 虚拟环境，方便命令行或 IDE 测试各种库，
          避免污染全局环境，相当于 Sandboxie
    * `pip`
        * 全局 pip 唯一需要安装的库是 `pipx`
        * pipdeptree
          pipdeptree 可以查看所属 pip 环境的树状依赖关系.
          如果不小心在全局 pip 安装了其他包，
          可以先在全局 pip 安装个 `pipdeptree`（本身只依赖 pip），
          使用 `pipdeptree` 命令查看每个包的依赖树，
          然后手动把不需要的包删掉。
    * `pyenv`    python 多版本切换
    * `Package Management` 管理的是 `Package Distribution`,即依赖管理

- Wheel
    * PyPI:
        从 PyPI 安装第三方库，
        本质是下载对应平台的 `wheel` `egg` `sdist` 文件然后安装，
        所以我们应该关注 wheel egg sdist 本身，
        以及对 python 来说「安装」的本质是什么
    * .whl 跨平台: 取决于是否带有 C/C++ 扩展，有则无法跨平台，反之则跨平台.

- zipapp
    * 不推荐使用。我的评价是，不如 pyinstaller/wheel
    * zipapp == 劣化版 jar
        * 为什么说是「劣化版」？
        * 无论是自己写的代码还是所使用的**第三方库**，
        都不能使用 C 语言的实现，一行都不行。
        因为 C 编译出来的是 Machine Code，无法跨 OS/CPU.
        * 如果应用程序依赖某个带有 C 扩展的包，
        则此程序包无法由打包文件运行
        （这是操作系统的限制，因为可执行代码必须存在于文件系统中，
        操作系统才能加载）。
        这时可去除打包文件中的依赖关系，
        然后要求用户事先安装好该程序包，
        或者与打包文件一起发布并在 __main__.py 中增加代码，
        将未打包模块的目录加入 sys.path 中。
        采用增加代码方式时，
        一定要为目标架构提供合适的二进制文件
        （可能还需在运行时根据用户的机器选择正确的版本加入 sys.path）。


|                      |                      | 作用      | Require             |
| -------------------- | -------------------- | ------- | ------------------- |
| .py                  | 纯模块                  | -       | Python环境            |
| .pyo                 | 纯模块                  | -       |                     |
| .pyc                 | 纯模块                  | -       |                     |
| .pyz                 | zipapp               | App     | Python环境 (+ 部分第三方库) |
| .pyd                 | 扩展模块                 | -       |                     |
| .so                  | 扩展模块                 | -       |                     |
| .class               | 扩展模块                 | -       |                     |
| 纯模块                  | Module               | -       |                     |
| 扩展模块                 | Module               | -       |                     |
| Module               | Module               | -       |                     |
| Package              | Package              | -       | Python环境            |
| Package Distribution | Package              | App/lib | -                   |
| Source Distribution  | Package Distribution | App/lib | -                   |
| Built Distribution   | Package Distribution | App/lib | -                   |
| Binary Distribution  | Package Distribution |         | -                   |
| sdist                | Source Distribution  | App/lib |                     |
| Egg                  | Built Distribution   | App/lib |                     |
| Wheel                | Built Distribution   | App/lib |                     |
| PEX                  |                      | App     |                     |
| zipapp               |                      | App     | Python环境 (+ 部分第三方库) |
| shiv                 |                      | App     |                     |
| Pyinstaller          | Freeze               | App     | 对应OS + 对应CPU        |
| Nuitka               | Freeze               | App     | 对应OS + 对应CPU        |
| py2exe               | Freeze               | App     | 对应OS + 对应CPU        |

Python Environment
    直接安装
    PEP 582
    venv
    conda
Module
    纯模块
        .py
        .pyo
        .pyc
    扩展模块
        .pyd (Windows dll)
        .so (Unix)
        .class (Jython)
Package
    folder with __init__.py
Distribution Package (i.e. App & lib)
    Source Distribution
        sdist
    Built Distribution
        egg    `.egg` `.egg-info`
        wheel    `.whl` `.dist-info`
    ???
        PEX (Python EXecutable)
        zipapp
        shiv
freeze 可执行文件
    pyinstaller
    nuitka
    py2exe


模块分 2 种，纯模块、扩展模块.
扩展模块可以理解为用 python 代码编译出的 IL，对于 CPython 的 IL 是 C/C++，Jython 的 IL 是 Java.

请注意 `Package` 和 `Dstribution Package` 是两个概念，pip wheel egg setuptool zipapp etc 针对的都是后者。

Python 最开始没有标准的分发格式，于是不同的工具开发了不同的分发格式，所以比较乱。例如 setuptool 引入了 Egg 分发格式。直到 PEP 427 钦定了分发格式 wheel

Egg 是一个由 setuptools 引入的 构建分发 格式，正在被 Wheel 取代。

pip, setuptools etc 工具都支持 wheel 格式

Built Distribution 相比 Source Distribution，在 install 之前多了一步 build

也就是说，我们平时所配置的 setup.py 的最终目的就是生成 wheel 文件然后上传到 PyPI 供他人安装

但还是有一点没有解释清楚，`pip install` 产生的 `.exe` 可执行文件是哪来的？exe 可执行文件应该不属于 wheel 的范畴吧？难道 setuptool 除了 wheel 还有其他黑魔法？

查了下，懂了。

pip install 产生的 .exe 效果等同于 scoop/shims 里的 exe。只不过 python 生成的 exe 是调用 python.exe 来执行入口函数，差不多等价于 `python entry_point.py`


## Con

- Con
    - 闭了个寂寞
    - 容易被逆向
    - 容易被破解

- References
    - [Python 源码混淆与加密](https://mp.weixin.qq.com/s/oQUfFIX3BK8_5-cRz-BaRg)

- Idea
    - 混淆
        - [[pyarmor]] 混淆+加密，代码级，仅此一家，但是收费
    - 打包
        - 高版本 Python 防止 [[uncompyle6]] 直接反编译
        - [[nuitka]] 编译为 [[C]] [[C++]]，极大提高逆向成本
        - Cython 编译为 [[C|C]] [[C++|C++]]
    - 加壳
        - [[pyinstaller]] [[nuitka]] 生成 excutable binary，对其加壳
        - [[UPX]] 压缩壳
        - 加密壳基本都收费

# SP

## Loop

### `__iter__()`

- Idea
    - Override `__iter__`
        - Support [[Python iter()|iter()]]
        - Support [[typing#Iterable|Iterable]]
        - Support `for`
    - Override `__iter__` + `__next__`
        - Support [[typing#Iterator|Iterator]]
        - Support [[Python iter()|iter()]]
        - Support [[typing#Iterable|Iterable]]
        - Support `for`

- API
    - `def __iter__(self) -> Iterator:`

- Fundamentals
    - [[Python iter()|iter()]]

- References
    - [对 Python 迭代的深入研究](https://kuanghy.github.io/2016/05/18/python-iteration)
    - [迭代器协议 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/c-api/iter.html)
    - [迭代器类型 - 内置类型 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/stdtypes.html#typeiter)
    - [Python进阶——什么是迭代器？ - 掘金](https://juejin.cn/post/6900373651099648014)
    - [itertools --- 为高效循环而创建迭代器的函数 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/itertools.html)
    - [第 6 章 循环与可迭代对象 - Python 工匠](https://www.zlovezl.cn/book/ch06_loop.html)

### `__next__()`

- Idea
    - Override `__iter__` + `__next__`
        - Support `next()`
        - Support `Iterator`
        - Support `Iterable`
        - Support `for in`

- API
    - `def __next__(self) -> Any:`
        - `return` value for this iteration of iterator
        - `raise StopIteration` to end

- Deps
    - `__next__` must be with `__iter__` to be overrode

### `__getitem__()`

- Idea
    - Override `__getitem__`
        - Support `o[index]` in right value
        - Support [[Python iter()|iter()]]
        - Support `Iterable`
        - Support `for in`

- API
    - `def __getitem__(self, index) -> Any:`
        - `return` value for given index
        - `raise StopIteration` to end

### `__setitem__()`

- Idea
    - Support `o[index] = value`

- API
    - `def __setitem__(self, key, value) -> None:`

### `__delitem__()`

- Idea
    - Support `del o[index]`

- API
    - `def __delitem__(self, index) -> None:`

### `__index__()`

- Idea
    - 貌似已经没啥用了

### `__missing__()`

- Idea
    - Support `o[unknown_key]` in right value
    - 索引不存在的 key

- API
    - `def __missing__(self, key) -> Any:`

- Fundamentals
    - 标准库实现的 `__getitem__` 支持 `__missing__`
        - `__getitem__` 执行过程中，找不到 key 则自动调用 `__missing__`，因此 override `__getitem__` 会阻止 `__missing__` 的调用，除非你自己实现
        - [[ChatGPT]]

### `__contains__()`

- Idea
    - Support [[typing#`Container`|Container]]
    - Support `in` operator

- API
    - `def __contains__(self, key) -> bool:`

- References
    - [Python进阶：自定义对象实现切片功能](https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg)

### `__len__()`

- Idea
    - Support `len()`
    - Support `Sized`

- API
    - `def __len__(self) -> int:`

### `__reversed__()`

- Idea
    - Support `reversed()` 反向迭代

- API
    - `def __reversed__(self) -> Iterable`

### `for`

- Idea
    - for each

- Fundamentals
    - [[Python iter()|iter()]] 获取迭代器，然后不断 `next()`

- Pro
    - Right value supports packing `,`
    - Left value supports unpacking `,`
    - Right value supports unpacking `*` `**` as if normal expression (not recommanded)
    - Left value supports packing `*` `**`

```python
for left_value in expr:
    continue  # 结束本次循环
    break  # 结束整个循环
else:
    # Optional
    # no run if break in for block
    # no run if return in for block
    # no run if raise in for block
    pass
```

### `while`

- Idea
    - while loop

- Fundamentals
    - `expr` 返回的对象通过 [[Python bool|bool()]] 判断布尔值，决定是否进入下一次循环

- Pro
    - `expr` 可不写，以形成无限循环

```python
while expr:
    continue  # 结束本次循环
    break  # 结束整个循环
else:
    # Optional
    # no run if break in while block
    # no run if return in while block
    # no run if raise in while block
    pass
```

### `[for]`

- Idea
    - 列表推导式
    - `value: List = [... for ... in ... for ... in ... if ...]`

- Pro
    - 零污染
        - `[for i in ...]` 的 `i` 作用域仅限于推导式内部，不会污染上一层命名空间

### `(for)`

- Idea
    - 生成器表达式
    - `value: Generator = (... for ... in ... for ... in ... if ...)`

- Pro
    - 零污染
        - `(for i in ...)` 的 `i` 作用域仅限于推导式内部，不会污染上一层命名空间

### `{for}`

- Idea
    - 字典推导式
    - `value: Dict = {...: ... for ... in ... if ...}`
    - 集合推导式
    - `value: Set = {... for ... in ... if ...}`

- Pro
    - 零污染
        - `{for i in ...}` 的 `i` 作用域仅限于推导式内部，不会污染上一层命名空间

## Branch

### `__bool__()`

- Edition
    - `__nonzero__` for Python 2
    - `__bool__` for Python 3

- Idea
    - Support `bool()`
    - Support `if`

- API
    - Override `def __bool__(self) -> bool`

### `__match_args__`

- Test
    - 都到这步了，干嘛不用 `if`
    - forced 禁止使用 `match-case`

- Idea
    - Support class pattern in `match-case`

- API
    - override `__match_args__: Tuple(str)`
        - 元素为 `__init__` 方法的形参名
        - 至少包括 `__init__` 的所有 required arguments

### `if`

- Fundamentals
    - `expr` 通过 [[Python bool|bool()]] 获取布尔值

```python
if expr:
    pass
elif expr:
    # Optional
    pass
elif expr:
    # elif can be specified multiple times
    pass
else:
    # Optional
    pass
```

### `match`

- Refernces
    - [PEP 636 – Structural Pattern Matching: Tutorial | peps.python.org](https://peps.python.org/pep-0636/)
    - [PEP 634 – Structural Pattern Matching: Specification | peps.python.org](https://peps.python.org/pep-0634/)
    - [PEP 622 – Structural Pattern Matching | peps.python.org](https://peps.python.org/pep-0622/)

- Test
    - 强烈不推荐
    - 比 `__getattribute__` 和 descriptor 加起来还要复杂！
    - Python specification 中第二复杂的特性（第一是泛型）
    - 比海象（Walrus）运算符还邪恶（match 有用到 walrus）
    - 我极少给什么打上"原罪"的标签，这算一个

- Idea
    - Fucking grammar sugar

- Deps
    - Python 3.10+

- Philosophy
    - patterns
        - `pattern` 是一门 DSL（就好比嵌入到 [[Perl]] 的 regexp）
        - 它既不是表达式（右值），也不是左值
        - 在此之前，Python Specification 不存在这样独立、割裂的 DSL，而都是统一、一致、和谐、自然、符合直觉的 statements 和 expression
        - TL;DR
        - `[0, 1, *foo]`
        - `{'x': 0, 'y': 1, **bar}`
        - 问题来了，这种 **既不是 left value 也不是 right value** 的语法，是合法的吗？
        - 答案是：合法。
        - 这种语法彻底破坏了 Python 关于「左值 & 右值」「语句 & 表达式」的一贯泾渭分明的哲学
        - Python 的哲学不再统一、完整、艺术
        - 我极少给什么打上"原罪"的标签，这算一个
        - 你要语法糖，那就像 [[Kotlin]] 那样，将语法糖作为核心特性，打磨成艺术品。而不是啪一下弄进来一个格格不入的 Lisp style 语法糖，还不如 [[Go]] 那样啥都没有
        - 退一万步说，`pattern` 比 `__getattribute__` 和 descriptor 加起来还要复杂，无论是逻辑还是实现
        - 完全违背了 Python 追求「简单」的哲学
        - There should be one-- and preferably only one --obvious way to do it.

```python
我认为「一致性」和「正交性」是语言设计中最能体现其优雅的部分，SQL 被嫌弃不就是因为那屎一般的正交性吗。而 Python 真正做到了这两点……直到 Python 3.8 的海象运算符（赋值表达式）与 Python 3.10 的 match pattern。它们彻底破坏了 Python 3.7 那堪称完美的「表达式」设计——

即任意复杂表达式可以分解为数个「最小表达式」的组合嵌套，而 **「不同的最小表达式之间能够用相同的语法（一致性）相互组合（正交性）」** ，这便是「符合直觉」的底层逻辑

海象运算符 `:=` ，或者说「赋值表达式」，它不是「表达式」！比如它不支持 unpacking、左值不能是对象的属性，这破坏了正交性

match pattern 则更过分，简单说它在一个「表达式」中嵌入了「未定义的变量」。pattern 和 `:=` 都在表达式中使用了未定义的变量，但 pattern 不使用赋值运算符 `=` 而是看起来「像」一个表达式。但它有着完全不同于的语法，它既不是「左值（语句）」，又不是「右值（表达式）」，放在 Python 3.7 完全就是错误的、不符合直觉、破坏一致性与正交性的语法糖。

顺便，我为什么对 JavaScript 充满偏见，很大一部分就源于令人作呕的语法糖、乱七八糟的正交性与一致性！

更进一步，正交性和一致性其实可以简化为对「左值」「右值」的理解，Python 将一切视为「语句」，「表达式」只是语句的右值，以此获得自然的语法；Rust 将一切视作「表达式」，编译器给所有语句添加上返回值，以此获得表达能力；Kotlin 另辟蹊径，小心翼翼地混用左值与右值，创造出一套自然的语法糖体系……尽管偶尔也有小瑕疵甚至大空洞，但好在这些黑洞的影响力并不大，即便是 Python 3.8 全面普及的现在， `:=` 语法糖也未被广泛接受，反而是更高版本的功能例如 Generic Type 成为了主流
```

- Objects
    - Patterns
        - Right value
            - instance
                - simple `switch-case` style by == `__eq__`
                - E.g. `Enum`
            - `Sequence`
            - `Mapping`
                - 究竟是 unpacking
                - 还是 `__eq__` 实现了遍历
        - Left value
            - `Sequnce` with `*`
            - `Mapping` with `**`
            - `foo` to capture
                - `foo` to new var name
                - `foo` use in block
            - `_` to ignore value
                - `_` not use in block
            - `T(arg1, arg2, arg3)` constructor
                - override `__match_args__`
            - `as`
                - `as` is optional in other left value patterns
        - Combination
            - `pattern | pattner`

- Fundamentals
    - Literal depended on `__eq__`

```python
match expr:
    case pattern:
        pass
    case pattern if guard:
        # 目测是先 if 再 pattern
        pass
    case _:
        pass
```

### `try`

- Idea
    - 错误处理

- Philosophy
    - try 其实也是一种「分支」
    - [[Go]]
        - try 相当于调用函数
        - raise 相当于 return
        - e 相当于返回值
        - e 的类型详见 [[Python Exceptions]]
        - [[C|C]] [[Go|Go]] [[Bash|Bash]] 就是利用返回值来处理异常的

```python
try:
    raise ExceptionGroup(...)
        * ExceptionGroup 里封装的异常必须是实例，而不是异常类.
except AttributeError[ as e]:
    * Optional
    e.add_note('more info')
    e.add_note('more info')
except (KeyError, ValueError)[ as e]:
    * Optional
    * no run if already entered above except clause.
    raise Exception from e
        * raise from 用来重置异常链，会丢失调用栈.
except:
    * Optional
    * no run if already entered above except clause.
except* ExGroup01:
    * Optional
    * require Python 3.11+
    * 处理 ExceptionGroup 中的某个异常.
except* ExGroup02:
    * 处理 ExceptionGroup 中的某个异常.
    * run even if another except* haves been excuted.
else:
    * Optional.
    * run if no enter except block.
    * no run if raise in try block.
    * no run if break in try block.
    * no run if return in try block.
    * 有 else 就必须要有 except，不能只使用 try else.
finally:
    * Optional.
    * run after try, except, else.
    * run anyway.
    * run if no raise/break/return in try/except/else block.
    * run if raise in try block.
    * run if break in try block.
    * run if return in try block.
    * run if raise in except block.
    * run if break in except block.
    * run if return in except block.
    * run if raise in else block.
    * run if break in else block.
    * run if return in else block.
    * 如果异常没被 except 处理，且 return/break/coutinue in finally clause，那么最后并不会抛出异常.
```

### `assert`

- References
    - [Python 中 assert 的最佳实践 | Leetao's Blog](https://leetaogoooo.github.io/2021/09/16/VXzqfuZ3G/)
    - [Python 中 assert 的最佳实践 - 知乎](https://zhuanlan.zhihu.com/p/411149531)

- Idea
    - `assert True` == `pass`
    - `assert False` == `raise AssertionError`
    - `assert obj` == `assert bool(obj)`

- Philosophy
    - `assert` 一般仅用于 Unit Test，请勿用于 App 代码
    - `AssertionError` 原则上不应被处理，而是直接抛出

- Examples
    - Unit Test 标记结果是否正常

## Main

- Idea
    - 指定入口文件 + 逐行执行

- CLI
    - `python foo.py`

- Philosophy
    - Script language
        1. 从源码文件第一行开始执行
        2. 执行完本行，才执行下一行
            - 仅有的例外是 `global` `nonlocal`，相当于 `global` `nonlocal` 那行自动移到 block 的开头
        3. 逐行执行，直至源码文件最后一行执行完成，程序退出
    - `import`
        - 导入其他 module，就相当于把那个源码文件执行一遍
        - 被导入的 module 也有 `import`，则 DFS（深度优先）递归导入

### `;`

- Idea
    - statement separator

- Philosophy
    - 虽然语法支持，但不推荐使用

### `\`

- Idea
    - 续行符 for expression
    - 续行符 for `'string'` `"string"` literals

- Alternatives
    - `()` `[]` `{}` 天生支持换行，无需显式换行符号

### `#`

[PEP 287 – reStructuredText Docstring Format | peps.python.org](https://peps.python.org/pep-0287/)

[Python风格规范 — Google 开源项目风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#section-8)

[用reStructuredText语法为代码写注释 · fastnlp/fastNLP Wiki](https://github.com/fastnlp/fastNLP/wiki/%E7%94%A8reStructuredText%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BB%A3%E7%A0%81%E5%86%99%E6%B3%A8%E9%87%8A)


```python
Out of date:
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-

Comment:
    # 单行注释

    """多行注释
    多行注释
    不推荐使用
    """

    # TODO(kl@gmail.com): Use a "*" here for string repetition.
    # TODO(Zeke) Change this to use relations.

    """docstring
    """

    # Annotation


docstring styles:
    * Google Style
        - E.g. aria2p library
    * reStructuredText (PEP 287)
        - E.g. plumbum
    * NumPy
    * Sphinx
    - 推荐 Google Style 或 rst，我选 Google Stlye，rst 我写不来.
    - IDEA - Settings - Tools - Python Integrated Tools - Docstrings


Google Style:

    def sum(x, y):
        """Add two number."""
        return x + y

    def cal(arg01, arg02):
        """
        Summary of function here.

        详细说明。
        一行太长，可用行尾「\」显式分行写。
        sdjflskdjfldskjfslk slkdjflksdj \
            sldkjfdsfjl sldjflkdsjfklds \
            lskdjflksdj sdlkfl lsdkjff \
            sldkjflkdsjf lskdjf

        随意写。

        函数：
            Args
            Returns
            Raises
        类：
            Attributes
        生成器：
            Yields
        常用：
            Example/Examples
            See Also
            References

        Args:
            x (int): xxxxxx
            table_handle (str): An open smalltable.Table instance.
            keys: A sequence of strings representing the key of each table
            row to fetch. String keys will be UTF-8 encoded.
            require_all_keys: Optional; If require_all_keys is True only
            rows with values set for all keys will be returned.
            Arg01:
                description line
                multi-line

        Returns:
            详细说明。

        Attributes:
            类的属性

        Yields:
            int: The next number in the range of 0 to `n` - 1.

        Raises:
            IOError: 列出与接口有关的所有异常，一个个说明

        Examples:
            举例

        Todo:
            * 列出
            * todo
        """
        pass

reStructuredText:
    def cal(arg01, arg02):
        """一句话说明，以英文 句点/问号/感叹号结尾.

        :param arg01: 说明
        :param str arg02: 说明
        :return: 说明

        :arg:
        :argument:
        :cvar:
        :except:
        :exception:
        :ivar:
        :key:
        :keyword:
        :param:
        :parameter:
        :raise:
        :raises:
        :return:
        :returns:
        :rtype:
        :var:

        还可以自由添加说明
        """
        pass

:func:`ShellSession.popen <plumbum.session.ShellSession.popen>`
:class: `...`
``None``


```

### `__doc__`

- Idea
    - `__doc__: str` 存储 docstring

### `__debug__`

- Idea
    - Python with `-O` sets `__debug__` to `False` and disables Python's `assert` statements

### `pass`

- Idea
    - 占位语句，什么也不做

# OOP

## `class`

```python
class MyClassName(Base01, Base02, Base03):  # Base classes are optional

    # all fields and method are optional
    foo: int = 0
    bar = None

    def __init__(self, x, y, **kwargs):
        self.x = x
        self.y = y

    def m(self, *args: int | float) -> float:
        return float(sum(*args))
```

### `is`

- References
    - [Python中神秘的-5到256 - 知乎](https://zhuanlan.zhihu.com/p/33907983?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)

- Fundamentals
    - `is` 操作会直接比较对象的 id（CPython 为内存地址），来判断是否为同一引用

### `del`

[Python进阶——如何正确使用魔法方法？（上） - 掘金](https://juejin.cn/post/6897938270080991240)

```python
del    手动销毁对象（自动是在垃圾回收时）

__del__ 这个方法就是我们经常说的「析构方法」，也就是在对象被垃圾回收时被调用

但是请注意，当我们执行 del obj 时，这个方法不一定会执行

由于 Python 是通过引用计数来进行垃圾回收的，如果这个实例在执行 del 时，还被其他对象引用，那么就不会触发执行 __del__ 方法
```

### `self`

- Idea
    - Auto bind `self` object for instance method

- Alternatives
    - In [[JavaScript]], it is similar to `this.func.bind(this)`

- Fundamentals
    - I guess the instantiation process use something like [[functools|self.method = functools.partial(MyClass.method, self)]]
    - `assert MyClass.method is not MyClass().method`
    - `MyClass.method` is the original function that requires `self` parameter
    - `MyClass().method` is a new function that does not require `self` due to bound already
    - [Descriptor Guide — Python 3.12.4 documentation](https://docs.python.org/3/howto/descriptor.html#functions-and-methods)

### `__name`

- References
    - [一切皆对象——Python面向对象（一）](https://mp.weixin.qq.com/s?__biz=MzU2MTU3ODI2Nw==&mid=2247483736&idx=1&sn=9802c789ab3cc3f31b84c9ac46c6c3fc&chksm=fc77e92ccb00603a81921976ff2c55cd2dd8d21b51a3b4fe5e0b52d6f1a273e5de4b575d15cd&scene=21#wechat_redirect)

- Idea
    - `__name` 可通过 `_ClassName__name` 访问

- Examples
    - 自定义 Mixin Class 及其方法时，担心引用了其他 Class 的属性？用 `__name` 可以避免这个问题？

- Philosophy
    - Python 没有真正的私有属性

### `__new__()`

- Idea
    - 实例化的 hook
    - 实现自定义元类

- API
    - `def __new__(cls, *args, **kwargs) -> Any:` 实例化 hook
    - `def __new__(cls, name, bases, attrs) -> type:` custom metaclass

### `__init__()`

```python
class T:
    def __init__(self[, 自定义]) -> None:
        """实例初始化."""

new:
    instance_var = T(...)

Default Instance:
    # Built-in Types
    * str()    ''
    * int()    0
    * bool()    False
    * list()    []
    * tuple()    ()
    * set()    empty set
    * dict()    {}
    - 默认实例，默认值，零值.

Description:
    - 每个 instance 有着自己的命名空间（准确地说是 stack），初始化时生成，GC 时销毁.
    - 同理，类定义时也会产生命名空间，毕竟类本身就是元类的实例.

```

### `__del__()`

- Idea
    - 垃圾回收 hook，引用计数为 0 才调用（即便手动 `del`）
    - 构析方法

### `__class__`

- References
    - [一切皆对象——Python面向对象（一）](https://mp.weixin.qq.com/s?__biz=MzU2MTU3ODI2Nw==&mid=2247483736&idx=1&sn=9802c789ab3cc3f31b84c9ac46c6c3fc&chksm=fc77e92ccb00603a81921976ff2c55cd2dd8d21b51a3b4fe5e0b52d6f1a273e5de4b575d15cd&scene=21#wechat_redirect)

- Idea
    - `type()` 隐式调用 `__class__`
    - `__class__: type` 属性可以强行通过「实例」访问「类本身」

### `__mro__`

- References
    - [Python MRO 探秘 - 掘金](https://juejin.cn/post/7081470992090365988)
    - [为什么继承 Python 内置类型会出问题？！](https://mp.weixin.qq.com/s/FtlVNTYq60KSPti2xD4psA)
    - [再谈 Python 中的继承（译） | Frost's Blog](https://frostming.com/2021/07-30/python-subclassing-redux-cn/)

- Objects
    - `o.__mro__: List[type]`

- Alternatives
    - `assert o.__mro__ == o.mro()`

### `__bases__`

- Idea
    - 所有直接父类

- API
    - `__bases__: Tuple(type)`

### `__base__`

- Idea
    - 第一个直接父类
    - 等价于 `__bases__[0]`

- API
    - `__base__: type`

### `__metaclass__`

- References
    - [Python进阶——什么是元类？ - 掘金](https://juejin.cn/post/6898878605406044174)

- Idea
    - 所有 Class 都是 Metaclass 的实例，`__metaclass__` 用于指明类初始化时所用的 Metaclass

- Examples
    - `type`
        - 按照 `__mro__` 依次寻找 `__metaclass__` 属性
        - 如果找不到，默认使用 `type` 作为元类

- Alternatives
    - 也可写成 `class C(metaclass=Meta)`

- Objects
    - 元类
        - Metaclass -> Class
        - Class -> instance
        - 任意 Class 都是 Metaclass 的 instance
        - Metaclass 也是 Class，也有 Metaclass
        - Metaclass 的 Metaclass 可以是其他 Metaclass，一般为 `type`
        - 所有 Class 都是 `type` 的 instance
        - 所有 Metaclass 都是 `type` 的 subclass

### `__mro_entries__()`

- References
    - [PEP 560 – Core support for typing module and generic types | peps.python.org](https://peps.python.org/pep-0560/)

### `__class_getitem__()`

- References
    - [PEP 560 – Core support for typing module and generic types | peps.python.org](https://peps.python.org/pep-0560/)

- Idea
    - Generic Types

### `__prepare__()`

- References
    - [一切皆对象——Python面向对象（二十一）：“准备“好类的命名空间](https://mp.weixin.qq.com/s?__biz=MzU2MTU3ODI2Nw==&mid=2247483976&idx=1&sn=902861a842f514a5684ea38f03ab9074&chksm=fc77ea3ccb00632a8860a2224b8155d6a9cb370cedbe34253104fc776361abc3cceefd51ad0d&cur_album_id=1514802197316845569&scene=189#wechat_redirect)

- API
    - `@classmethod`
    - `def __prepare__(cls, name, bases)`

### `__subclasses__()`

- Idea
    - `MyClass.__subclasses__() -> List[type]`
    - 获取 `MyClass` 的 subclasses

- API
    - 我不确定能不能 override，但是看上去没必要 override

### `__instancecheck__()`

- Idea
    - Support [[Python isinstance()|isinstance()]]

- API
    - `def __instancecheck__(self, instance)`

### `__subclasscheck__()`

- Idea
    - Support [[Python issubclass()|issubclass()]]

- API
    - `def __subclasscheck__(self, subclass)`

### `__hash__()`

- Idea
    - the hash value of an object must never change
    - Support [[Python hash()|hash()]]
    - Support `Hashable`

- Test
    - 对 `is` 无效

- Deps
    - `__hash__` `__eq__` 务必同时 override

- Fundamentals
    - All objects in Python are hashable by default
    - but if you've written a custom `__eq__` method then your objects won't be hashable without a custom `__hash__` method
    - 对象自带 C 源码中的 `PyBaseObject_Type`（好像是这名字）的 `__hash__` 方法
    - 默认 `__hash__` 返回对象的 id（CPython 为内存地址）

- References
    - [Every dunder method in Python - Python Morsels](https://www.pythonmorsels.com/every-dunder-method/)

### `__eq__()`

- Idea
    - == 运算符

- Fundamentals
    - Python objects comes with this method by default
    - default `__eq__` relies on `is` operator, which checks for id

- Dependencies
    - override `__eq__()`，务必同时 override `__hash__()`
    - override `__eq__` 但没有 override `__hash__`，则 `__hash__` 自动为 `None`

### `__buitins__`

- Idea
    * 内置命名空间

### `__dict__`

- References
    - [一切皆对象——Python面向对象（一）](https://mp.weixin.qq.com/s?__biz=MzU2MTU3ODI2Nw==&mid=2247483736&idx=1&sn=9802c789ab3cc3f31b84c9ac46c6c3fc&chksm=fc77e92ccb00603a81921976ff2c55cd2dd8d21b51a3b4fe5e0b52d6f1a273e5de4b575d15cd&scene=21#wechat_redirect)

- Idea
    - `__dict__: mappingproxy`
    - Module 的 `__dict__` 属性是 Namespace 的具体实现
    - instance 的 `__dict__` 属性存储的是 属性键值对
    - `assert o.name is o.__dict__['name']`

- Fundamentals
    - Python byte code
        - `.foo` 这样的操作，叫作 `LOAD_ATTR` & `STORE_ATTR`
        - `.foo()` 为 `LOAD_METHOD` `CALL_METHOD`

### `__slots__`

- Idea
    - 限制 `.` 左值可修改的属性

- API
    - override `__slots__: List[str]` 可修改属性列表

- Fundamentals
    - 貌似 `__slots__` 会破坏 `__dict__`，有待研究

### `__dir__()`

- Idea
    - Support [[Python dir()|dir()]]

- Examples
    - 默认已自带，返回对象命名空间所有标识符 `__dict__.keys()`

- API
    - `def __dir__(self) -> List:[str]`

### `__getattribute__()` & `__getattr__()` & `__setattr__()` & `__delattr__()`

[高阶编程：魔术方法应用实战 | Python源码剖析](https://fasionchan.com/python-source/class-mechanism/magic-method/)

[从 Python 的魔法方法说开去 | Frost's Blog](https://frostming.com/2020/05-12/python-magic-method/)

[collections.abc --- 容器的抽象基类 — Python 3.11.1 文档](https://docs.python.org/zh-cn/3/library/collections.abc.html#collections-abstract-base-classes)

[3. Data model — Python 3 documentation](https://docs.python.org/3/reference/datamodel.html#special-method-names)

[3. Data model — Python 2.7.18 documentation](https://docs.python.org/2.7/reference/datamodel.html#special-method-names)

[Python进阶——如何正确使用魔法方法？（下） - 掘金](https://juejin.cn/post/6898313346182250503)

[从 Python 的魔法方法说开去 | Frost's Blog](https://frostming.com/2020/05-12/python-magic-method/)

[Python进阶——如何正确使用魔法方法？（上） - 掘金](https://juejin.cn/post/6897938270080991240)

[动态属性 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E5%85%83%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7.html)

[11. (译)Python魔法方法指南 — 一起写Python文章，一起看Python文章](https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#python-3)

[当__getattr__()遇上@property，坑倒Python老司机_赖勇浩的博客-CSDN博客](https://blog.csdn.net/gzlaiyonghao/article/details/115534278)

[3. 数据模型 — Python 3.11.1 文档](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__slots__)

[内置类型 — Python 3.11.1 文档](https://docs.python.org/zh-cn/3/library/stdtypes.html#special-attributes)

[typing —— 类型注解支持 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/typing.html)

[对象注解属性的最佳实践 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/howto/annotations.html)

[具体的对象层 (各种对象) — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/c-api/concrete.html)

[Python 描述器简述](https://rgb-24bit.github.io/blog/2018/python-descriptor.html)

- Philosophy
    - Python 一切皆对象
    - 对象 == 属性的集合
    - 对象 == 实例

- Idea
    - Left Value
        - `.`: `__setattr__`
        - `del` `.`: `__delattr__`
        - `setattr()`: `__setattr__`
        - `delattr()`: `__delattr__`
    - Right Value
        - `.`: `__getattribute__` 访问任意属性时都会被调用
        - `.`: `__getattr__` 访问不存在的属性
        - `getattr()`: `__getattribute__`
        - `getattr()`: `__getattr__`

- API
    - `def __getattribute__(self, key) -> Any`
    - `def __getattr__(self, key) -> Any`
    - `def __setattr__(self, key, value) -> None`
    - `def __delattr__(self, key) -> None:`

- Objects
    - Object
        - Class attributes
        - Instance attributes
    - Class attributes
        - Method
            - Class method
            - Static method
        - Class field
            - Python 不允许「只声明不赋值」，因此类字段必须要赋值（dataclass 的"字段"本质是实例属性，而不是类字段，而且它是有默认值的，其实任何一个对象属性都是有默认值的）
        - Inner Class
    - Instance attributes
        - Instance method
        - Instance property
            - 「类属性」与「实例属性」没有本质区别，二者都是「对象的属性」，它们只不过是初始化的时机不一样

```python
class App:

    def __setattr__(self, key, value) -> None:
        """setattr(key, value)

        通过「.」属性赋值.
        """
        if key not in ('name', 'age'):
            return
        if key == 'age' and value < 0:
            raise ValueError()
        super(Person, self).__setattr__(key, value)

    def __getattr__(self, key):
        """访问不存在的属性."""
        return 'unknown'

    def __delattr__(self, key):
        """删除某个属性."""
        if key == 'name':
            raise AttributeError()
        super(Person, self).__delattr__(key)

    def __getattribute__(self, key):
        """所有属性/方法的调用都经过这里.

        __getattribute__ 不仅针对所有属性访问，还包括方法调用.
        __getattr__ 只针对不存在的属性.
        """
        if key == 'money':
            return 100
        if key == 'hello':
            return self.say
        return super(Person, self).__getattribute__(key)

```

### `__get__()` & `__set__()` & `__delete__()`

[Python进阶——什么是描述符？ - 掘金](https://juejin.cn/post/6906102041068699655)

[Python 描述器简述](https://rgb-24bit.github.io/blog/2018/python-descriptor.html)

[3. 数据模型 - 实现描述器 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptors)

[描述器使用指南 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/howto/descriptor.html#descriptorhowto)

[友好的 Python：扩展友好 | Frost's Blog](https://frostming.com/2021/07-07/friendly-python-1/)

[一文彻底搞懂 Python中的描述器、反射 | 小杰玩编程](https://izhaojie.com/2021/08/19/python-descriptor.html)

- Idea
    - descriptor == hook of `__getattribute__`
    - 当类属性是 descriptor 时，`__getattribute__` 会有很复杂的返回行为
    - 简单来说，descriptor「影响」`__getattribute__`「最终返回值」
    - 可以把「描述符」理解为：对象的属性不再是一个具体的值，而是交给了一个方法去定义

- Objects
    - Descriptor
        - Descriptor MUST be a **class attribute**

- Architecture
    - `__getattribute__` `__getattr__` `__setattr__` `__delattr__` 控制了「返回哪个对象」
    - 对于类属性，如果「返回的对象」带有 `__get__` `__set__` `__del__`，那么「最终返回值」将会委托给 `__get__` `__set__` `__del__` 来返回，而非直接返回对象本身
    - 这样的 类属性 称为 描述符

- Fundamentals
    - Implement by `__getattribute__`
        - 「不返回对象本身」而是「返回对象的 `__get__` `__set__` `__del__` 的调用」。这种做法是有些反直觉的，因此，我想弄清楚，「返回 `__get__` 的调用」究竟是谁实现的？是默认的 `__getattribute__` `__getattr__` 方法？还是与属性的魔法方法无关？
        - 答案是 `__getattribute__`
        - `__getattribute__` 实现了「调用描述器的方法作为返回值」
        - 查找顺序：数据描述符、实例属性、非数据描述符、类属性
        - 因此 override `__getattribute__` 要十分慎重，这会阻止 descriptor 的调用
        - [Python进阶——什么是描述符？ - 掘金](https://juejin.cn/post/6906102041068699655)

- Examples
    - 所有方法都是 non-data descriptor，因为其只有 `__get__` 属性

```python
非数据の描述符: def __get__(self, obj, type=None) -> Any
数据の描述符1: def __get__(self, obj, type=None) -> Any
数据の描述符1: def __set__(self, obj, value) -> None
数据の描述符2: def __get__(self, obj, type=None) -> Any
数据の描述符2: def __delete__(self, obj) -> None

* Descriptor 是一个类.
* Descriptor Instance 是 Descriptor 的实例.
* 实现 __get__/__set__/__delete__ 的任意一个，即 Descriptor.
* 只定义了 __get__，叫做 Non-data Descriptor.
* 除了 __get__，还定义了 __set__ 或 __delete__，叫 Data Descriptor.


描述器仅限于「类属性」吗？「实例属性」不能用吗？那这样的话「类属性」「实例属性」就是有明确区分了，就像「函数」「方法」那样……又或者是「类属性」会在「类初始化」时会特殊处理描述器，而「实例属性」在「实例初始化」时不会特殊处理描述器？

经过测试，结论是后者。「类初始化」时会特殊处理描述器，「实例初始化」不会。因此，「类属性」「实例属性」没有本质区别，二者只不过是初始化的时机不同，另外不同时机的初始化会有不同的处理。初始化之后，是无法只通过实例对象本身来区分哪个属性是类属性，哪个是实例属性。

经过更深入的测试，以上结论都不对。「类属性」「实例属性」比我想象的要复杂，区别也很大。或许不会像「方法」「函数」那样泾渭分明，但 CPython 对「类属性」「实例属性」有着**完全不同**的处理，不仅限于初始化的时间不一样、初始化时的处理不一样，哪怕是**实例化之后**，访问类属性与访问实例属性在底层有着不同的处理。

Python 的类具有一个特殊的字典叫 __dict__ ，它被称作命名空间，说白了就是一个存放对象所有属性的字典。

类中的所有方法其实都是一个非数据描述符，因为它定义了 __get__
在类中会把 function 放到 __dict__ 中存储
描述符可以分为数据描述符和非数据描述符
之后我们又分析了获取一个属性的过程，一切的入口都在 __getattribute__
Python 描述符提供了强大的属性访问控制功能，我们可以在需要对属性进行复杂控制的场景中去使用它
```

### `__enter__()` & `__exit__()`

- References
    - [Python进阶——什么是上下文管理器？ - 掘金](https://juejin.cn/post/6900029472926334983)

```python
with T(): def __enter__(self) -> Any
with T(): def __exit__(self, exc_type, exc_value, exc_traceback)->None
with contextlib.closing(T()): def close(self) -> None:
```

### `__call__()`

- API
    - `def __call__(self[, 自定义])[ -> Any:]`

### `__copy__()`

- Idea
    - Support `copy.copy()`

- API
    - `def __copy__(self) -> self:.__class__`
 
### `__deepcopy__()`

- Idea
    - Support `copy.deepcopy()`

- API
    - `def __deepcopy__(self) -> self:.__class__`

### `__getstate__()` & `__setstate__()` & `__getinitargs__()` & `__getnewargs__()` & `__reduce__()` & `__reduce_ex__()`

```python
pickle.dumps(): def __getstate__(self) -> Any    序列化
pickle.loads(): def __setstate__(self, state) -> None    反序列化
pickle: def __getinitargs__(self, ) -> 
pickle: def __getnewargs__(self, ) -> 
pickle: def __reduce__(self, ) -> 
pickle: def __reduce_ex__(self, ) -> 
```

## `:`

- Idea
    - Declare variable type
    - `:` 只是 Declaration，不会影响执行及其结果

- API
    - `foo: T`
    - `foo: T = ...`
    - `def foo() -> T:`

- References
    - [PEP 484 – Type Hints | peps.python.org](https://peps.python.org/pep-0484/)
    - [PEP 526 – Syntax for Variable Annotations | peps.python.org](https://peps.python.org/pep-0526/)
    - [PEP 3107 – Function Annotations | peps.python.org](https://peps.python.org/pep-3107/)
    - [PEP 482 – Literature Overview for Type Hints | peps.python.org](https://peps.python.org/pep-0482/)

### `nonlocal`

- Idea
    - declare a var in non-local namespace

- DSL
    - 当前 block 中，只能在 `nonlocal` 之后才能使用该标识符，否则会语法报错

### `global`

- Idea
    - declare a var in global namespace (current module's namespace)

- DSL
    - 当前 block 中，只能在 `global` 之后才能使用该标识符，否则会语法报错

- Fundamentals
    - `global` 是真正的"声明"，bytecode 也是声明

## =

- References
    - [PEP 526 – Syntax for Variable Annotations | peps.python.org](https://peps.python.org/pep-0526/)
    - [静态类型检测 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AF%87/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B.html)
    - [Python陷阱：为什么不能用可变对象作为默认参数的值 - FooFish](https://foofish.net/python-tricks.html)
    - [Type Annotation 使用情况统计](https://blog.orsinium.dev/posts/py/core-devs-typing/)

- Philosophy
    - 命名规范
        - 默认 蛇形小写
        - Constant 蛇形全大写
        - Class 大驼峰
        - 项目根文件夹 随意起名
    - 无需声明
        - Python 变量无需单独声明，单独声明虽然语法层面不报错，但运行时并不会生成对象，一般仅用作给 IDE 进行语法补全
        - Python 变量只需直接赋值
    - Pointer
        - Python 有一级指针（按引用传递），但没有二级指针
    - Scope
        - 引用一个 name 时，按照如下顺序查找
        - local scope (innermost scope) (current namespace)
        - nonlocal scope (non-local but non-global namespace)
        - global scope (next-to-last scope) (module''s namespace)
        - buitins namespace (outermost scope)

- Objects
    - Assignment
        - 狭义的赋值：= 赋值操作符
        - 广义的赋值：任何产生标识符或修改标识符指向的行为。包括 = `def` `class` `import` `for` `:=` `match` etc
    - Left Value
        - = 的左侧部分叫作「左值」
            - Identifier
                - Variable
                - Parameter
                - 「标识符」在 Python 官方文档中一般称为「name」
                - `/^[a-zA-Z_]{1}[a-zA-Z0-9_]+$/`
            - Object attribute
            - `Container` item i.e. `obj[index]`
            - `del`
            - Unpacking i.e. `x, y, z = ...`
            - Packing i.e. `*tuple_var = ...` `**dict_var = ...`
        - 任何形式的赋值，当 Right Value 是一个「不可变对象」，则「按值传递」
            - 对「不可变对象」进行「浅拷贝」，生成一个新对象
            - Left Value 指向 新对象
            - 这个过程是隐式的，自动完成
        - 任何形式的赋值，当 Right Value 是一个「可变对象」，则「按引用传递」
            - Left Value 指向 可变对象
    - Right Value
        - = 的右侧部分叫作「右值」
        - Right Value 必须是一个 Expression
    - Expression
        - Expression 返回一个对象
        - Expression 有且仅有一个返回值
        - Expression 的求值是一种递归计算
            - Variable
                - 指向「可变对象」，返回对象本身（对象的 id，或者说是内存地址）
                - 指向「不可变对象」，返回对象的浅拷贝
            - Parameter 同上
            - Call 同上
            - Object attribute 同上
            - `Container` item 同上
            - Unpacking i.e. `*` `**`
                - 每次隐式 iteration 返回对象为「可变对象」，返回对象本身
                - 每次隐式 iteration 返回对象为「不可变对象」，返回对象的浅拷贝
        - Expression 的严格定义很难用一两句话说清楚，具体去看 C 源码的语法解析
        - Expression 的代码级定义很复杂，但对于人类，判断、书写表达式是一件非常轻松且自然的事情，因此不再深究其定义
        - 严格来说，Python 是一门只有 statement 的语言。因为单纯的 expression 等价于 `_ = expression`。但如果 `from foo import bar as _`，则停止赋值给 `_` 的行为

- Examples
    - `_`: 不关心的占位变量
        - 语法层面与其他变量无异，但编译器可能会优化性能
        - CPython 并未对此进行性能优化
    - `avg`: average
    - `c`: controller
    - `col`: column
    - `cls`: class
    - `cmd`: command
    - `cfg`: configuration
    - `config`: configuration
    - `ctx`: context
    - `dst`: destination
    - `e`: exception
    - `ex`: exception
    - `el`: element
    - `err`: error
    - `f`: file
    - `f`: function
    - `i, j, k`: iterated item
    - `klass`: class
    - `num`: number
    - `np`: numpy
    - `p`: parser
    - `pd`: pandas
    - `pkg`: package
    - `req`: request
    - `res`: response
    - `res`: result
    - `ret`: result
    - `ret`: return
    - `src`: source
    - `stmt`: statement
    - `typ`: type
    - `x, y, z`: variable

- API
```python
Packing & Unpacking:
    Unpacking
        - `*` unpacking Iterable
        - `**` unpacking iterable container (E.g. Dict[str, Any])
        - 意味着一次隐式迭代.
    Packing
        - `*` packing items to a tuple
        - `**` packing keyword-argumens to a Dict[str, Any]
        - 也意味着一次隐式迭代.
    赋值语句 の Packing & Unpacking
        * E.g.
        * `v01, v02, v03, v04, *v05 = e01, *exp01, e02, e03`
        * 右边解包后，至少要有 5 个对象.
        * 右边解包无论是大于还是等于 5 个对象，v05 都是个 tuple.
    for 循环 の Packing & Unpacking
        * E.g.
        * for v01, v02, v03, v04 in e01, *exp01, e02: pass
        * for i, (name, code) in enumerate(colors): pass
        * for i,j,k in zip(iter01, iter02, iter03): pass
    for 推导式 の Packing & Unpacking
        * E.g.
        * [expr for v1, v2, *v3 in e1, *i01, e2, e3]
        * (expr for v1, v2, *v3 in e1, *i01, e2, e3)
    函数定义 の Packing & Unpacking
    函数调用 の Packing & Unpacking
```

- Fundamentals
    - [Python Scopes and Namespaces | 9. Classes — Python 3.11.1 documentation](https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces)
```python
* A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries.
* By the way, I use the word attribute for any name following a dot — for example, in the expression z.real, real is an attribute of the object z.
* A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace.
* 「Namespace」命名空间是在内存中真实存在的 Mapping 对象，CPython 中的 Namespace 几乎都是个字典 dict 对象.
* 「Scope」作用域，官方的说法是 scope is textually，即「作用域是字面上的，是字面意思的」。而且细读文档，
* 关于命名空间和作用域的具体定义，官方文档说的不明不白，这是我找到的唯一显式阐述「命名空间」和「作用域」的文档，居然才只占一小节
* Each module has its own private namespace, which is used as the global namespace by all functions defined in the module.
* each module is only imported once per interpreter session.
* if you change your modules, you must restart the interpreter – or, if it’s just one module you want to test interactively, use importlib.reload(), e.g. import importlib; importlib.reload(modulename).
* buitins 命名空间里的 names 可以直接用，例如内置函数、内置类.
* 导入 module 所产生的 namespace，默认不会销毁，生命周期直到 Python 解释器退出才结束，这也解释了为何每个模块只会导入一次.
* 使用（引用 reference）一个标识符（name），就是在访问属性。对于全局变量，就是在访问 module 的属性. speaking, references to names in modules are attribute references: in the expression modname.funcname, modname is a module object and funcname is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace!
* Module 的 __dict__ 属性，就是 Module 的 Namespace 是具体实现. Module objects have a secret read-only attribute called __dict__ which returns the dictionary used to implement the module’s namespace; the name dict is an attribute but not a global name. Obviously, using this violates the abstraction of namespace implementation, and should be restricted to things like post-mortem debuggers.
```

## `import`

[7. 简单语句 - import 语句 — Python 3 文档](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import)

[5. 导入系统 — Python 3 文档](https://docs.python.org/zh-cn/3/reference/import.html)

[你的 Python 包都装到哪了？ | Frost's Blog](https://frostming.com/2019/03-13/where-do-your-packages-go/)

[The Module Search Path | 6. Modules — Python 3.11.1 documentation](https://docs.python.org/3/tutorial/modules.html#the-module-search-path)

[The initialization of the sys.path module search path — Python 3.11.1 documentation](https://docs.python.org/3/library/sys_path_init.html)

[在 Python 中使用 vendor 的方法 | Frost's Blog](https://frostming.com/2022/03-12/how-to-vendor-in-python/)

[深入 Python import 机制 | SinHub's Blog](https://sinhub.cn/2019/05/python-import-machinery-part-one/)

[深入 Python import 机制 —— PEP 302：新的 import hook | SinHub's Blog](https://sinhub.cn/2019/05/python-import-machinery-part-two/)

[模块的预设字段 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%A8%A1%E5%9D%97/%E6%A8%A1%E5%9D%97%E7%9A%84%E9%A2%84%E8%AE%BE%E5%AD%97%E6%AE%B5.html)

[模块的加载流程 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%A8%A1%E5%9D%97/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.html)

[导入时与运行时 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%A8%A1%E5%9D%97/%E5%AF%BC%E5%85%A5%E6%97%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6.html)

[模块加载特殊内容 · python攻略](https://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E6%A8%A1%E5%9D%97/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%89%B9%E6%AE%8A%E5%86%85%E5%AE%B9.html)

[import_hook · python攻略](https://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E5%85%83%E7%BC%96%E7%A8%8B/import_hook.html)

[vscode中使用python相对路径问题? - 给你宇宙的回答 - 知乎](https://www.zhihu.com/question/313379182/answer/2274244007)

[Python 相对导入与绝对导入](https://kuanghy.github.io/2016/07/21/python-import-relative-and-absolute)

[详解Python import机制(二):绝对导入与相对导入 - 掘金](https://juejin.cn/post/6844903969819459597)

[学习Javascript闭包（Closure） - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)

- References
    - [Python的循环导入问题 - Xjng - 博客园](https://www.cnblogs.com/Xjng/p/10672422.html)
    - [Python 中循环 import 造成的问题如何解决？ - dacaoxin的回答 - 知乎](https://www.zhihu.com/question/19887316/answer/697939321)

    - [Code Structure and Multiple Files - SQLModel](https://sqlmodel.tiangolo.com/tutorial/code-structure/)

- Pro
    - 循环导入会报错 `ImportError`
        - `if` `def` 中的 `import` 能绕过，请小心

- Test
    - 避免 非全局导入
        - 别把 `import` 放进 `if` `def` etc
        - 除非要兼容不同 Python 版本

- 使用 `import` `__import__()` 导入其他模块
    - 强烈推荐「显式绝对导入」
    - 尽量少用「显式相对导入」
    - 绝对不要「隐式相对导入」
- 模块搜索
    - E.g. `from foo.bar import a`
    - 最重要的是找到 `foo` 模块（包）在哪
    - `sys.path` 包含一堆文件夹路径，解释器会依次在每个文件夹下寻找名为 `foo` 的模块（包），找到为止。然后顺着找到 `bar` 模块
    - 没了，就是这么简单，其实标准库也是这样导入的
- `sys.path`
    - 自带 cwd/主文件所在目录
    - 自带 `PYTHONPATH` 环境变量
        - 格式为 `<path>:<path>:...` 或 `<path>;<path>;...`.
    - 自带 解释器的 pip
    - 自带 标准库

- `dir(module)` 获取非当前模块里的标识符
- `globals()` 获取当前模块里的标识符
- `locals()` 获取当前命名空间里的标识符

[[ChatGPT]] 是的，Python 中命名空间是实际存在的对象。命名空间是一个字典（dictionary），用于存储变量名和变量值之间的映射关系。在 Python 中，每个命名空间都是一个对象，包括内置命名空间、全局命名空间和局部命名空间。通过 Python 的内置函数（如 locals() 和 globals()）可以访问局部和全局命名空间。因此，命名空间可被视为普通的 Python 对象，可以被直接访问和操作。

是的，模块也是一个命名空间。在 Python 中，每个模块都有自己的命名空间，模块的全局变量被存储在该命名空间中。这样可以防止不同模块中定义的同名变量之间产生冲突。当我们在一个模块中导入另一个模块时，被导入的模块的命名空间可以被访问和使用。例如，我们可以通过语句“import math”来导入 Python 的内置 math 模块，然后使用该模块中定义的变量和函数。

```python
* import 语句通过内置函数 __import__() 来查找模块、获取模块对象.
* import 语句，不管何种形式，可概括为，「在当前 namespace 创建指定标识符，要么该标识符指向一个模块对象（import foo、import a.b.c），要么该标识符指向模块对象的属性（from foo import bar、from a.b import c）」.
* import 语句可分为「绝对导入」「显式相对导入」「隐式相对导入」.
* 隐式相对导入 早就被 PEP8 命令禁止，绝对不要用.
* 显式相对导入 形如 from . import xxx，即 from 后边紧跟「.」字符.
* 显式相对导入 基于 __name__，所以不能在主脚本里使用，因为 `__name__ == '__main__'`，不知道模块的路径.
* from .a.b import xxx 中的 "." 表示当前模块，".a.b" 表示从当前模块的子模块 a 的子模块 b 导入 xxx.


* 「导入」，就是让我们在这个代码文件里能够使用另一个文件里写的代码。这种说法高度概括，对人类来说简单易懂，但对计算机来说则不够严谨.
* 「导入」的精确定义，对于 Python 来说，就是「从另一个模块的作用域里获取指定对象（获取对象的唯一 id，对于 CPython 来说即内存地址），在当前命名空间里创建标识符，将获取的对象赋值给当前命名空间的标识符（标识符指向该内存地址）」.
* 这段话是我根据官方文档、实测求证总结而来，虽然文笔不行，但用语力求严谨，提到的几个概念「模块 Module」「作用域 Scope」「对象id」「赋值」严格遵循官方文档的定义.
* 粗糙的说，导入就是赋值（这点在 JS 体现的很明显），要么是简单的变量赋值，要么是是给模块对象的属性进行赋值.
* 根据上述定义，我们发现了「一个模块只会导入一次」的真相，即模块里的对象只会创建一次，内存里有且仅有一份该对象，但是可以有多个标识符指向它（增加引用计数）。但这种说法并不严谨，没考虑到「不可变对象」的赋值「原则上」是「按值传递」，是会生成一个新对象的。为什么强调是原则上，因为 CPython 为了节省内存、优化性能，「可能」会让不同标识符指向同一不可变对象，比如 CPython 对小于等于 256 的整数就是这么处理的.


* 一个 Module（模块），就是一个 .py 文件.
* Package 只是一种特殊的 Module.
* 任何具有 __path__ 属性的 Module 都会被当作是 Package.
* 一律绝对导入，禁止相对导入，无论是显式相对导入还是隐式相对导入.
    * Python 官方和 PEP8 都明确不推荐使用隐式相对导入.
    * 显式相对导入非常不由雅，大多数人都不用.
    * 最重要的是 nuitka、pyinstaller 等工具压根不支持相对导入.
    * 不由雅、兼容性差，永远不要使用相对导入.
    * 一律绝对导入.


* `import` 默认从环境变量 `PYTHONPATH` 里的目录查找模块，非常好修改.
* 如果我们导入的「标识符」是「模块」或「包」，我们只能访问该对象的「属性」，不能访问它的「子模块/子包」.
* `import a.b.c` 之所以能够访问子包 b，是因为对象 a 有个名为 b 的属性，而 b 有个名为 c 的属性，我们访问的属性，而不是子包。如果只是 `import a`，a 是不会有名为 b 的属性的。也就是说，对于 `import a.b.c as a1` 与 `import a as a2`，a1 与 a2 是两个不同的对象，a1 有着名为 b 属性，而 a2 则没有 b 属性。真是个糟糕的隐式特性.


为了弄清楚 logging.config 与 loguru.logger，我需要获取对象的内存地址的方法
我理解了！任何一个 Python 模块里的对象，只会被创建一次。
__import__() 创建的模块对象，可以理解为创建了一个 JS 的 object，这个对象的属性，指向的就是模块里的对象。
也就是说，所谓的 import 导入，就是创建了一个变量，这个变量是一个模块对象，模块对象的一些属性，分别指向了另一个对象的属性。
所谓的 from import 导入，就是创建了一个变量，这个变量直接指向另一个对象的属性。
另一个对象，就是我们常说的模块（包）。实际上「模块」在内存里就是一个对象，跟普通变量没什么区别。这就是「每个模块只会被导入一次」的真相，更准确的说法应该是「Python 模块的每一个对象只会被创建（定义/赋值）一次」。
这里更是阐明了一个重要本质，所谓「变量赋值」，本质上是「对象属性赋值」。所谓「变量」，或者说「标识符」，本质上是「命名空间的属性」。
「全局作用域」==「模块对象」，是一个「命名空间对象」。
「局部作用域」是一个「命名空间对象」。
也就是说，「全局变量赋值」==「给模块命名空间对象の属性进行赋值」。
也就是说，「局部变量赋值」==「给局部命名空间对象の属性进行赋值」。
综上，loguru 的 logger 无论在哪个模块，都指向同一个对象。但 logger.bind() 方法会创建一个新对象，目测是 logger 的浅拷贝，然后修改这个对象的属性，就能达到不同模块拥有不同 logger 的效果。


import a.b.c.d.e  # b 必须是模块（或包）……e 必须是模块（或包）
a  # 标识符
a.b  # 可用，但这并不是标识符，标识符不能有字符「.」
a.b.c  # 可用，但这并不是标识符，标识符不能有字符「.」
a.b.c.d  # 可用，但这并不是标识符，标识符不能有字符「.」
a.b.c.d.e  # 可用，但这并不是标识符，标识符不能有字符「.」
有歧义。只会生成 1 个标识符，但是相比 `import a` 会有 4 个额外的属性访问

import a
a  # 标识符，可用
a.b  # 不可用
a.b.c  # 不可用
a.b.c.d  # 不可用
a.b.c.d.e  # 不可用


from a.b.c.d import e  # b 必须是模块（或包）……d 必须是模块（或包）
e  # 标识符，可用
a  # 不可用
a.b  # 不可用
a.b.c  # 不可用
a.b.c.d  # 不可用
a.b.c.d.e  # 不可用
from import 没有任何歧义，只会生成 1 个标识符


from a import p
p  # 标识符，可用
a  # 不可用
a.b  # 不可用
a.b.c  # 不可用
a.b.c.d  # 不可用
a.b.c.d.e  # 不可用
from import 没有任何歧义，只会生成 1 个标识符


import logging
import logging as log01
import logging.config as log02
print(logging is log01)  # True
print(logging is log02)  # False
print(log01 is log02)  # False

from foo import * # 不会导入以下划线开头的对象
```

### `__file__`

- Idea
    - Code file path of current module

- API
    - `__file__: str`

- Fundamentals
    - 该变量在模块被导入时创建，由于每个模块只会导入一次，因此其值不会变，可以当作常量

### `__name__`

- Idea
    - Imported path of current module

- API
    - `__name__: str`

- Fundamentals
    - 该变量在模块被导入时创建，由于每个模块只会导入一次，因此其值不会变，可以当作常量

### `__spec__`

- Idea
    - 当前模块的 `ModuleSpec` 对象
    - Replace `__file__` `__name__`

- API
    - `__spec__: ModuleSpec`

- Fundamentals
    - 该变量在模块被导入时创建，由于每个模块只会导入一次，因此其值不会变，可以当作常量

### `__all__`

- Idea
    - Select what objects will be imported for `from mod import *` syntax

- API
    - `__all__: List[str]`
        - `str`: identifier in global namespace

### `__init__`

- Idea
    - A Python module with `__init__` attribute will be seem as a *package*

### `__main__`

- Idea
    - `python -m <mod> [args]` == `python mod/__main__.py`

# 结构化并发

## `yield`

- References
    - [Python进阶——如何正确使用yield？ - 掘金](https://juejin.cn/post/6900733030340493319)
    - [Python进阶——什么是迭代器？ - 掘金](https://juejin.cn/post/6900373651099648014)

- 定义异步函数推荐使用 async，而不是用过时的 yield (from).
- yield (from) 目前主要用途是懒加载.
- 在生成器函数中使用 `return` 可以提前退出函数，若只有 `yield` 会运行完整个函数


**变迭代变输出**

Iterator (迭代器) == Iterator Object (迭代器对象)
Iterator Class (迭代器类)
Generator (生成器) == Generator Object (生成器对象)

Iterator (迭代器对象)
Iterable (可迭代) == Iterable Object (可迭代对象): string, list, tuple, dict, set, bytes, generator object, iterator object

iter() 迭代一次
next() 迭代一次
for 迭代全部（遍历）

`yield from g` 等价于 `for i in g: yield i`
next(obj) 可以看作等价于 obj.send(None)


生成器最佳应用场景是：必须使用同步/阻塞时，你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环

一个「生成器对象」是一个特殊的「迭代器对象」。

一个对象才能成为迭代器！所以「迭代器 iterator」也叫「迭代器对象 iterator object」。注意，迭代器不是这个对象所属的类，类 != 迭代器；但 迭代器 == 迭代器对象。或许我们可以将这个类称为「迭代器类 iterator class」，而「迭代器」作为「迭代器对象」的简称。

「生成器 generator」是「生成器对象 generator object」的简称。一个「生成器对象」是由一个使用了 yield 的函数返回的，我们可以叫这个函数为「生成器函数 generator function」

任意对象，只要定义了__next__方法，它就是一个迭代器

迭代器有两个基本的方法：iter() 和 next()。

生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。




【生成器表达式】
用小括号包裹的推导式，表达式的值是一个 生成器对象
( x * 2 for x in range(5) )
(expression for item in Sequence )
(expression for item in Sequence if conditional )

生成器表达式一般用来写较为简单的生成器对象。生成器函数代码可能稍多一点，但可以返回逻辑更为复杂的生成器对象。所以生成器表达式就是简化匿名版的 generator function



## `async`/`await`

[Python Asyncio 之常见的三个坑 - So1n blog](https://so1n.me/2023/12/28/python_asyncio_lib_how_to_use_it_correctly/)

[PEP 492 部分翻译 - 大白的碎碎念](https://www.bwangel.me/2016/10/12/pep-492-%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91/)

- Ecosystem
    - Async
    - [Asyncio - 异步库超赞合集 awesome list chinese](https://asmcn.icopy.site/awesome/awesome-asyncio/)
    - [public-apis/public-apis: A collective list of free APIs](https://github.com/public-apis/public-apis)
    - [TonnyL/Awesome\_APIs: :octocat: A collection of APIs](https://github.com/TonnyL/Awesome_APIs/tree/master)
    - [Kr1s77/awesome-python-login-model: 😮python模拟登陆一些大型网站，还有一些简单的爬虫，希望对你们有所帮助❤️，如果喜欢记得给个star哦🌟](https://github.com/Kr1s77/awesome-python-login-model)
    - [dataabc/weiboSpider: 新浪微博爬虫，用python爬取新浪微博数据](https://github.com/dataabc/weiboSpider)
    - [awesome-web-scraping/python.md at master · lorien/awesome-web-scraping · GitHub](https://github.com/lorien/awesome-web-scraping/blob/master/python.md#browser-automation)

`asyncio.loop.run_in_executor()` 用于在已经运行的「协程」中使用「多进程」「多线程」。尤其是多进程，能并行 CPU 密集型任务

`multiprocessing.pool.Pool.apply_async()` 用于在已经运行的「线程」中使用「多进程」。其实直接在线程中创建多个 Process 实例也是没问题的，但没有 `apply_async()` 灵活
 
```python
async def:
await
async with
async for
await in

python 3.5 才出现 async/await
python 3.8 出现了关键字 coroutine

await: def __await__() -> Awaitable
async with: def __aenter__() -> 
async with: def __aexit__() -> 
async for: def __aiter__() -> 
async for: def __anext__() -> 




可迭代对象
迭代器
生成器
可等待对象

这就是为啥说 await 可理解为 yield from。

但是更进一步思考会发现，async 函数只能返回一次，yield from 和 yield 已经没有区别了。

只返回一次是故意这么设计的，只有这样才能直接把一个普通函数通过 async 关键字变为协程函数。

我又想了想，那生成器函数改协程函数呢呢？这个是返回多次还是一次返回多个？






协程

1. push 多个 task；
2. 每个 task 执行到 yield 处交出执行权给线程，等待响应；如果没遇到 yield，那就一直执行完这个 task，然后交出运行权给线程；
3. 无缝切换到下一个 task，又从第 2 步开始执行；
4. yield 响应了，切换到对应 task 继续执行，如果 task 剩余部分还有 yield，又从第 2 步的开始执行，如果 task 剩余部分没有 yield 了，那就一直执行完这个 task，然后交出运行权给线程；
5. 无缝切换到下一个 task，又从第 2 步开始执行；
6. 执行完所有 task，释放线程；






避免使用 async def 的方法，貌似不存在。按照我的理解，调用链中，从 asyncio.run 到一个 async def 函数之间的所有函数，必须是协程函数 async def。这样的话，异步要想改为同步，就必须将调用链的所有协程函数全部重写成普通函数，同步转异步同理。

我的要求是，不改造调用链的普通函数为前提（只允许写一次 async def），用协程实现并发。……我悟了，这是做不到的，因为整个循环体是单线程的，所以我们写的回调一定要是非阻塞的，否则就失去了异步的优势了。如果回调函数有io操作，**那么需要将此回调异步化**

所谓回调异步化，就是 async def 整个调用链。这是无法避免的。


```


# FP

## `def`

[Function 对象 - 具体的对象层 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/c-api/concrete.html#function-objects)

[functools --- 高阶函数和可调用对象上的操作 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/functools.html)

[调用协议 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/c-api/call.html)

[函数的参数 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888)

[7.2 只接受关键字参数的函数 — python3-cookbook 3.0.0 文档](https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p02_functions_that_only_accept_keyword_arguments.html)

[Python陷阱：为什么不能用可变对象作为默认参数的值 - FooFish](https://foofish.net/python-tricks.html)

[PEP 484 – Type Hints | peps.python.org](https://peps.python.org/pep-0484/)

[PEP 3102 – Keyword-Only Arguments | peps.python.org](https://peps.python.org/pep-3102/)

[PEP 468 – Preserving the order of \*\*kwargs in a function. | peps.python.org](https://peps.python.org/pep-0468/)

- Pro
    - 支持 Type Annotations
        - 支持 泛型
    - 支持 Closure（返回函数对象）
    - 支持 高阶函数（传入函数对象）
    - 支持 [[functools|Overload]]（仅限第一个形参）

```python

* 每次的函数调用都会创建一个新的命名空间，函数返回时命名空间的生命周期结束.
* 函数参数的默认值在函数定义时就会完成初始化，并且只会进行这一次计算，这些值跟随函数的生命周期，保存在 function definition scope，目测是一个隐式的命名空间。不同的函数调用，参数指向的是同一默认值对象.

Formal Arguments (Formal Parameters):
    def func(
        # Positional-only parameters
        required_positional_argument_1,
        required_positional_argument_2,
        required_positional_argument_3,
        optional_positional_argument_1,
        optional_positional_argument_2,
        optional_positional_argument_3,
        /,  # Positional-Only before, Positional-or-Keyword after
        required_argument_1,
        required_argument_2,
        required_argument_3,
        optional_argument_1,
        optional_argument_2,
        optional_argument_3,
        *args: T,  # Arbitrary Argument Lists
        keyword_argument_1,
        keyword_argument_2,
        keyword_argument_3,
        keyword_only_argument_7,
        keyword_only_argument_8,
        keyword_only_argument_9,
        named_argument_4,
        named_argument_5,
        named_argument_6,
        **kwargs: T  # Arbitrary Keyword Arguments
    ):
        args: List[T]
        kwargs: Dict[str, T]



Actual Arguments (Actual Parameters):
    





在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。

但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

必选参数    没有默认值的、正常的入参
默认参数=xxx    有默认值的、正常的入参
*可变参数    可指定多个值的入参
命名关键字参数[=xxx]    不懂有啥用，跟必选参数、默认参数有区别吗？
**关键字参数    可传入多个未知的参数名

单一职责，一个函数只做一件事，开闭原则，对扩展开放，对修改关闭。

def func_param(
    # 5 种入参的定义顺序不能乱
    # 必选参数（可以无数个）
    must01: int,
    must02: str,
    must03,
    # 默认参数（可选，可以无数个）
    default01=None,
    default02=233,
    default03=999,
    # 可变参数（可选，只能有 1 个，为 tuple）
    *args: int,
    # args 是一个元组
    # 命名关键字参数（可以无数个）
    # *,
    # 如果前边没有可变参数，需使用「*,」分隔，不然跟默认参数混在一起了
    # 命名关键字的作用是？
    # 目测，函数调用时**必须**指定参数名，
    # 而必选参数、默认参数可以省略参数名而只靠顺序填值
    name01,  # 无默认值，必选
    name02=0,  # 可选
    name03=999,
    # 关键字参数
    # 填入时可以无数个
    # 解析时当成 1 个变量，为 Dict
    # `**kw` 能传给别的函数，当作 必选参数、可选参数、命名关键字参数
    # func_param(kw001=0, kw002=999)
    **kw: int
):
    print(name01 is None)
    isinstance(name02, int)
    isinstance(name03, int)
    isinstance(args, tuple)
    isinstance(kw, dict)
    return kw


# 调用并传入参数
a01 = func_param(
    'must01',
    'must02',
    'must03',
    'default01',  # 可选
    default03='',  # 可选
    *(0, 1, '*args', 'tuple'),  # 可选
    name01='',  # 可选
    name03=7,  # 可选
    fjsldk2389r='',
    sldkfldkfslkdfjlskdjf='',
    dhnfshvdjsf='',
    sdklnnsdfj='',
    unknown01='',
    unknown02='',
    unknown03='',
)
print(a01)
```

## `__annotations__`

- References
    - [PEP 3107 – Function Annotations | peps.python.org](https://peps.python.org/pep-3107/)
    - [PEP 563 – Postponed Evaluation of Annotations | peps.python.org](https://peps.python.org/pep-0563/)
    - [Python强类型编程最佳实践——PyCon2020分享-阿里云开发者社区](https://developer.aliyun.com/article/782788)

- Idea
    - `f.__annotations__: Dict[str, type]` == 函数签名的本质
    - 根据类型注解自动生成字典
    - key 为形参名或 `'return'`
    - value 为注解的类型
    - 如果没有任何注解，则为空字典
    - 如果没有进行类型注解，则对应 key 不存在

## `lambda`

```python
def func01(x):
    return x**2

func02 = lambda x: x**2

assert func01(9) == func02(9)
```

## `@`

- References
    - [Python进阶——如何实现一个装饰器？ - 掘金](https://juejin.cn/post/6897784801055473677)
    - [PEP 3129 – Class Decorators | peps.python.org](https://peps.python.org/pep-3129/)

- Syntax
    - `@deco01`
    - `@deco02`
    - `@deco03`
    - `func = deco01( deco02( deco03(func) ) )`

- API
    - `@DecoratorWith(arg01, arg02)`
        - `class DecoratorWith`
            - `def __init__(self, arg01, arg02) -> None:`
            - `def __call__(self, func) -> Callable:[..., ...]`
            - `def __call__(self, cls) -> type:`
            - `def __call__(self, func_or_cls) -> Any:`
    - `@Decorator`
        - `class Decorator`
            - `def __call__(self, func) -> Callable:[..., ...]`
            - `def __call__(self, cls) -> type:`
            - `def __call__(self, func_or_cls) -> Any:`
    - `@decorator_with(arg01, arg02)`
        - `def decorator_with(arg01, arg02):`
            - `def decorator(func) -> Callable[..., ...]`
            - `def decorator(cls) -> type`
            - `def decorator(func_or_cls) -> Any:`
    - `@decorator`
        - `def decorator(func) -> Callable[..., ...]`
            - `def wrapper(*args, **kwargs) -> Any:`
            - `return wrapper`
            - 简单对 function 进行装饰
        - `def decorator(cls) -> type`
            - `def wrapper(*args, **kwargs) -> Any:`
                - 形参一般直接用于初始化 cls，传递给它的 `__init__`
            - `return wrapper`
            - 简单对 Class 进行装饰
        - `def decorator(func_or_cls) -> Any`
            - 无论被装饰的是函数还是类，理论上我们可以返回任意对象，非常灵活

## `__<operator>__`

[operator --- 标准运算符替代函数 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/operator.html)

[one-python-craftsman/15-thinking-in-edge-cases.md at master · piglei/one-python-craftsman](https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/15-thinking-in-edge-cases.md)

```python
...
    * Three dots is alias for Ellipsis.
    * Ellipsis 是一个 Python 常量，类型是 ellipsis.


*    iterable unpacking operator
**    dictionary unpacking operator


+
-
*
/
//    地板除（舍去小数）
%
**    次方
math.sqrt(x)    开根号
pow(x, a)    x^a
round(2.3)    四舍五入（x.5 不稳定，有时候向上，有时候向下）
math.floor(2.3)    舍去小数
math.ceil(2.3)    向上取整
int(a)    float to int 舍去小数（python 3 将 int 和 long 合并成了 int）
int('-1209')    str to int 舍去小数
float(a)    int to float
float('-1209')    str to float
str(a)    number to str

==
!=
>
<
>=
<=

=    赋值
+=    尽量少用
      如果对象实现了 __iadd__()，操作等价于 a = a.__iadd__(i)
      __iadd__ 不存在，才等价于 a = a + i
      其他赋值运算符同理
-=
*=
/=
%=
**=
//=
if-else三元运算符 true_value if condition else false_value

&    按位与
|    按位或
~    按位取反
^    按位异或
<<    左移
>>    右移

and    逻辑与（返回第一个真值为 False 的对象，都为 True 则返回右侧对象）
or    逻辑或（实际上返回的是「第一个布尔值为真的对象」，而不是返回布尔值）
not    逻辑非（返回 True/False）

in     如果在指定的序列中找到值返回 True，否则返回 False。隐式迭代
not in    成员运算符

is     两个标识符是不是引用同一个对象
not is    身份运算符
+: def __pow__(self, obj) -> Any
-: def __neg__(self, obj) -> Any
~: def __invert__(self, obj) -> 

>: def __gt__(self, other) -> bool
>=: def __ge__(self, other) -> bool
<: def __lt__(self, other) -> bool
<=: def __le__(self, other) -> bool
==: def __eq__(self, other) -> bool
    raise NotImplemented: cannot be compared
!=: def __ne__(self, other) -> bool
~~def __cmp__(self, other) -> int~~    Python 2

+: def __add__(self, other) -> Any
+: def __radd__(self, other) -> Any    反射加法
+=: def __iadd__(self, other) -> Any    增量加法

-: def __sub__(self, other) -> Any
-: def __rsub__(self, other) -> Any
-=: def __isub__(self, other) -> Any

*: def __mul__(self, other) -> Any
*: def __rmul__(self, other) -> Any
*=: def __imul__(self, other) -> Any

/: def __truediv__(self, other) -> Any
/: def __rtruediv__(self, other) -> Any
/=: def __itruediv__(self, other) -> Any

//: def __floordiv__(self, other) -> Any
//: def __rfloordiv__(self, other) -> Any
//=: def __ifloordiv__(self, other) -> Any

%: def __moddiv__(self, other) -> Any
%: def __rmoddiv__(self, other) -> Any
%=: def __imoddiv__(self, other) -> Any

**: def __pow__(self, other) -> Any
**: def __rpow__(self, other) -> Any
**=: def __ipow__(self, other) -> Any

&: def __and__(self, other) -> Any
&: def __rand__(self, other) -> Any
&=: def __iand__(self, other) -> Any

|: def __or__(self, other) -> Any
|: def __ror__(self, other) -> Any
|=: def __ior__(self, other) -> Any

^: def __xor__(self, other) -> Any
^: def __rxor__(self, other) -> Any

<<: def __lshift__(self, other) -> Any
<<: def __rlshift__(self, other) -> Any
<<=: def __ilshift__(self, other) -> Any

>>: def __rshift__(self, other) -> Any
>>: def __rrshift__(self, other) -> Any
>>=: def __irshift__(self, other) -> Any


str()1: def __str__(self, obj) -> str
str()2: def __repr__(self, obj) -> str
bytes(): def __bytes__(self, obj) -> bytes
~~unicode(): def __unicode__(self, obj) -> unicode:~~    Python 2
int(): def __int__(self, obj) -> int
float(): def __float__(self, obj) -> float
complex(): def __complex__(self, obj) -> complex
bool(): def __bool__(self, obj) -> bool
~~bool(): def __nonzero__(self, obj) -> bool~~    Python 2
reversed(): def __reversed__(self) -> 


repr()1: def __repr__(self) -> str
repr()2: def __str__(self) -> str
format(): def __format__(self, ) -> str
bin(): def __bin__(self) -> str
oct(): def __oct__(self) -> str
hex(): def __hex__(self) -> str
round(): def __round__(self) -> int
abs(): def __abs__(self) -> int
divmod(): def __divmod__(self, other)
math.floor(): def __floor__(self) -> int
math.ceil(): def __ceil__(self) -> int
math.trunc(): def __trunc__(self) -> int
```
