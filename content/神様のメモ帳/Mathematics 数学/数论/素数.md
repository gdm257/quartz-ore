---
aliases:
  - Prime Number
  - 素数
tags:
  - flag/Mathematics-数学/数系/数论
  - Label/Mathematics-数学/Number
---

要得到自然数 n 以内的全部素数

1. 试除法（除数一般都能想到不超过 n/2，但其实只需要除到 sqrt(n) 即可）
2. 埃氏筛法（从2开始删去素数本身倍数，向后找到的第一个数字一定是素数。把不大于 sqrt(n) 的所有素数的倍数剔除，剩下的就是素数。复杂度 O(nloglogn)）
3. 欧拉筛法、线性筛法（本质是优化的埃氏筛法，保证每个合数只被它的最小质因数筛去，复杂度 O(n)，因此也叫线性筛）
4. Miller Rabin


埃氏筛法

判断自然数n以内的全部质数，将不大于sqrt(n)的所有质数的倍数剔除，剩下的即为该自然数n以内的所有质数

Step 1. 先设定整个序列均标记为质数

Step 2. 取出整个序列的第一个质数 P，此时为 2

Step 3. 将该质数在n以内的倍数全部标记为非质数

Step 4. 根据标记信息按序取该序列中下一个质数Q（此时为3），先判断其平方值是否超过n，如果是，则该算法结束，质数与否标记完成；否则，返回Step 3

```java
// 计数 n 以内素数的数量
public int countPrimes(int n) {
    boolean[] notPrime = new boolean[n];
    int num = 0;
    for(int i=2; i<n; i++)
    {
        if(!notPrime[i])
        {
            num++;
            for(int j = 2; i*j < n; j++)    // 将该质数的倍数标记为非质数
            {
                notPrime[i*j] = true;
            }
        }
    }
    return num;
}
```







在数论，对正整数n，欧拉函数是小于或等于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler's totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。

注意，欧拉筛法不是遍历到 sqrt(n)。比如 6，2 < sqrt(6) < 3，如果只遍历到小于 sqrt(6) 的 2，2*2 = 4，没法筛掉 6，所以不是遍历到 sqrt(n)。

埃氏筛法看似简单，其实核心很难看出，就是你要怎么找到 sqrt(n) 以内的素数？递归吗，确实可以，不过你真的想写递归吗。真正の埃氏筛核心：从2开始删去素数本身倍数，向后找到的第一个数字一定是素数。证明：简略一说，设已找到第n个素数，删去此数自身倍数后找到剩下的第一个数字L，知L之前有且仅有n个素数，且都无法整除L，**即L无法被小于自身的所有素数整除，推出L是素数**（L就是第n+1个素数）。照此由第一个素数2往后递推即可。所以不要再以为筛法就是“删去合数最后留下素数”了，这个说法虽说正确，但完全没有说到点子上，仅仅是在描述显而易见的事实。

在实现形式上，埃氏筛是直接用素数遍乘自然数删去自身倍数；线性筛是先建立一个素数数列，然后用每个自然数遍乘数列中的素数删去素数倍数。比如埃氏筛法中6在已经被2筛去的情况下又被3筛了一遍，而我们希望6只被2筛去。这样就可以将整个算法的时间复杂度从O(nloglogn)降到O(n)，这样随着n增大时间复杂度也仅线性增大。

算法简述：

s1：建立标记数列（从2到n的自然数）和素数数列；

s2：第一个数字是2（看标记是素数），把素数2放进素数数列，标记2×2为非素数；

s3：第二个数字是3（看标记是素数），把素数3放入素数数列，标记3×2、3×3为非素数；

s4：第三个数字是4（看标记是合数），标记4×2为非素数，break；

s5：第四个数字是5（看标记是素数），把素数5放入素数数列，标记5×2、5×3、5×5为非素数；

s6：第五个数字是6（看标记是合数），标记6×2为非素数，break；

s7：第六个数字是7（看标记是素数），把素数7放入素数数列，标记7×2、7×3、7×5、7×7为非素数；

```c
//目标：应用线性筛法找到给定整数n以内的所有素数。（n不大于一亿）
#include<stdio.h>
int a[100000001]={0},p[50000000];
int main()
{
	int n,i,j,k=0;
	scanf("%d",&n);
	for(i=2;i<=n;i++)
	{
		if(a[i]==0)
		{
			k++;
			p[k]=i;
			//printf("%d、",i);
		}
                for(j=1;j<=k&&i*p[j]<=n;j++)
		{
			a[i*p[j]]=1;
			if(i%p[j]==0)break;
		}
	}
	printf("共%d个素数\n",k);
	return 0;
}
```

那么为什么以上的步骤能实现目标呢？线性筛的改进就一句“每个合数只被它的最小质因数筛去”，但实现的时候需要以下两个逻辑支撑：

一、每个合数只筛一次

①算法特性决定了找到的素数只能从自身开始乘。比如找到素数5时，它的2、3、4倍已经删不到了，这样避免了重复删。（虽然单独列出但也可以合并进②）

②if(i%p[j]==0)break;语句实现不重复删。证明很简单，自然数i从最小素数2开始乘，i×p[j]以每个p[j]为最小质因数，直到p[j]整除i时，i×p[j]还是以p[j]为最小质因数，但下一个数i×p[j+1]=(i/p[j])×p[j]×p[j+1]中p[j+1]就不是最小质因数了，所以不必继续乘了。

二、不能干扰到运用埃氏筛核心原理找素数

①与②共同实现不重复筛的同时导致了素数倍数的缺失，比如程序运行到s7时，7是个标记素数（没被当合数删除），那么素数2、3、5要从2倍一直删到倍数大于7才能保证7确实是个素数，但明眼的看表就知道缺失了好多素数倍数啊，怎么能证明这些缺失不影响素数的确定呢？

证明：首先①②中不重复筛的合数最终会出现在图表中（延迟删去）。设L是标记素数，把小于L的所有素数倍数放入集合Q中，用q表示Q中任意素数倍数，则q<L<2L，由于图中素数倍数的大小排列特性，q<2L意味着小于L的素数倍数都会在步骤s(L)之前被删去，这样得证①和②不影响素数的确定。因L不被小于它的所有素数整除，所以L是素数。

综上就是线性筛的算法逻辑，为证明它需要考虑的出乎意料地多，理解“if(i%p[j]==0)break;”语句也才仅仅是理解皮毛（值得一提的是，即使删去此语句，余下的部分也是相当优秀的程序）。

最后可以用这个方法验证一下线性筛法是否不漏筛不复筛：把合数按最小质因数的不同对应All2、All3、All5、All7、All11、All13···等集合，看看从2到n的任意一个合数是否都能放入唯一的对应集合中。至于是不是，自己走一遍流程看看吧……
## 试除法

[[Python|Python]]

```python
def is_prime_number(n: int) -> bool:
    """试除法判断素数.

    原理是从2除到平方根，余数为0则不是素数.

    Args:
        n (int): any integer

    Returns:
        bool: prime number or not
    """
    return (
        # Negative, 0 and 1
        False
        if n <= 1
        # 2 and higher
        else all((n % i != 0) for i in range(2, int(n**0.5) + 1))
    )


if __name__ == '__main__':
    [print(i) for i in range(-100, 100) if is_prime_number(i)]
    print(49999991, is_prime_number(49999991))
    print(99999989, is_prime_number(99999989))
    # print(439351292910452432574786963588089477522344331, is_prime_number(439351292910452432574786963588089477522344331))

```

## 埃氏筛法

[[Python|Python]]

```python
from typing import List


def get_prime_number(n: int) -> List[int]:
    """埃氏筛法获取素数.

    Args:
        n (int): 任意正整数

    Returns:
        List[int]: 所有小于n的素数
    """
    composite_num = set()
    prime_number = []
    for i in range(2, n + 1):
        if i not in composite_num:
            prime_number.append(i)
            if i <= pow(n, 0.5):
                end = n // i + 1
                for j in range(2, end):
                    # if i * j not in composite_num:
                    composite_num.add(i * j)
    return prime_number


if __name__ == '__main__':
    print(get_prime_number(2_000))

```
